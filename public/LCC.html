<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Logan Interactive Mapping</title>

<link rel="icon" type="image/png" href="./images/Flavour icon.png">

<!-- Optional: ArcGIS embeddable map loader (not used by this build, kept for future use) -->
<script type="module" src="https://js.arcgis.com/4.34/embeddable-components/"></script>

<!-- ===== Non-intrusive performance hints (no functional changes) ===== -->
<link rel="preconnect" href="https://js.arcgis.com" crossorigin>
<link rel="dns-prefetch" href="//js.arcgis.com">
<link rel="preconnect" href="https://geocode.arcgis.com" crossorigin>
<link rel="dns-prefetch" href="//geocode.arcgis.com">
<link rel="preconnect" href="https://cornerstonebc.maps.arcgis.com" crossorigin>
<link rel="dns-prefetch" href="//cornerstonebc.maps.arcgis.com">
<link rel="preconnect" href="https://services.arcgis.com" crossorigin>
<link rel="dns-prefetch" href="//services.arcgis.com">

<link rel="preload" as="style" href="https://js.arcgis.com/4.30/@arcgis/core/assets/esri/themes/light/main.css" crossorigin>
<link rel="stylesheet" href="https://js.arcgis.com/4.30/@arcgis/core/assets/esri/themes/light/main.css" crossorigin>

<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/portal/Portal.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/WebMap.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/views/MapView.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/Graphic.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/layers/GraphicsLayer.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/widgets/Search.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/widgets/Expand.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/widgets/ScaleBar.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/widgets/Home.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/widgets/LayerList.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/widgets/Legend.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/widgets/BasemapGallery.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/widgets/Fullscreen.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/core/reactiveUtils.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/geometry/geometryEngine.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/symbols/support/symbolUtils.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/rest/locator.js" crossorigin>
<link rel="modulepreload" href="https://js.arcgis.com/4.30/@arcgis/core/config.js" crossorigin>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" integrity="sha512-q+4liFwdPC/bNdhUpZx6aXDx/h77yEQtn4I1slHydcbZK34nLaR3cAeYSJshoxIOq3mjEf7xJE8YWIUHMn+oCQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<!-- ===== End performance hints ===== -->

<style>
  :root{ --brand:#a70b13; --brand2:#7f0e15; --bg:#f6f7f9; --ink:#0b0d12; --border:#e1e3e6; --radius:14px; --shadow:0 6px 18px rgba(16,21,28,.08); }
  html,body{height:100%;margin:0}
  body{display:flex;flex-direction:column;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}

  header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 16px;color:#fff;background:linear-gradient(90deg,var(--brand),var(--brand2));box-shadow:var(--shadow)}
  .brand{font-weight:800;letter-spacing:.2px}
  .toolbar{display:flex;gap:10px;flex-wrap:wrap}
  .btn{border:none;border-radius:999px;padding:10px 14px;cursor:pointer;color:#fff;background:rgba(255,255,255,.14)}
  .btn:hover{background:rgba(255,255,255,.22)}
  .btn.linklike{background:transparent;border:1px solid rgba(255,255,255,.45)}

  #contextBar{display:flex;flex-wrap:wrap;gap:12px;align-items:center;padding:8px 16px;background:#fff;border-bottom:1px solid var(--border)}
  .badge{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);background:#fff;border-radius:999px;padding:4px 10px;font-size:12px}

  main{flex:1;min-height:520px;display:grid;grid-template-columns:clamp(280px,24vw,420px) 1fr;gap:12px;padding:12px}
  #left{min-width:280px;background:#fff;border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);display:flex;flex-direction:column;overflow:auto;max-height:calc(100vh - 140px);height:calc(100vh - 140px);scrollbar-width:thin;scrollbar-color:#c7cbd1 transparent}
  #left::-webkit-scrollbar{ width: 8px; }
  #left::-webkit-scrollbar-thumb{ background:#c7cbd1; border-radius:6px; }
  #left::-webkit-scrollbar-track{ background:transparent; }
  #viewWrap{position:relative;border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden}
  #viewDiv{position:absolute;inset:0}

  .panel{display:none;padding:12px;overflow:auto;max-height:calc(100vh - 200px)}
  .panel.active{display:block}
  .pod-form{display:flex;flex-direction:column;gap:8px;margin-top:6px}
  .pod-form input[type="file"]{display:none}
  .pod-upload-row{display:flex;align-items:center;gap:10px}
  .pod-upload-btn{display:inline-flex;align-items:center;gap:6px;padding:10px 14px;border-radius:12px;border:1px solid #d0d4dc;background:#fff;color:var(--ink);font-weight:600;font-size:13px;cursor:pointer;box-shadow:inset 0 1px 0 rgba(255,255,255,.6),0 1px 3px rgba(0,0,0,.08)}
  .pod-upload-btn:hover{border-color:#b3b9c6;background:#f7f9fc}
  .pod-drop{border:1px dashed #c5cad3;border-radius:12px;padding:10px;transition:background .2s,border-color .2s}
  .pod-drop.dragover{background:#f2f5fb;border-color:#7f9ad5}
  .pod-file-name{font-size:13px;color:#6b7280;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .pod-form .btn.full{width:100%;text-align:center}
  .pod-status{font-size:12px;color:#4b5563;margin-top:6px;min-height:18px}
  .pod-status.error{color:#b42318}
  .pod-results{margin-top:10px;border-top:1px solid var(--border);padding-top:8px;max-height:200px;overflow-y:auto;overflow-x:hidden}
  .pod-results ul{margin:0;padding-left:18px;font-size:13px}
  .pod-result-row{display:flex;align-items:center;gap:8px;margin:6px 0}
  .pod-zoom-btn{border:1px solid #d0d4dc;background:#f7f9fc;border-radius:10px;padding:6px 10px;font-size:12px;cursor:pointer}
  .pod-zoom-btn:hover{background:#eef2f7;border-color:#b3b9c6}
  .pod-details{max-height:280px;overflow:auto}
  .pod-details summary{cursor:pointer;font-weight:600;font-size:15px;list-style:none}
  .pod-details summary::-webkit-details-marker{display:none}
  .pod-details summary::after{content:"+";float:right;font-size:12px;color:#666}
  .pod-details[open] summary::after{content:"-"}
  /* Darken POD panel to align with map-theme */
  #podUploadCard{background:var(--map-panel,#1b1c20);border:1px solid var(--map-border,#2b2c33);color:var(--map-ink,#f5f5f8);}
  #podUploadCard .section-title,#podUploadCard summary{color:var(--map-ink,#f5f5f8);}
  #podUploadCard p,#podUploadCard .pod-status,#podUploadCard .pod-file-name{color:var(--map-muted,#9ea1ab);}
  #podUploadCard .pod-result-row{color:var(--map-ink,#f5f5f8);}
  #podUploadCard .pod-results{border-color:var(--map-border,#2b2c33);}
  #podUploadCard .pod-zoom-btn{background:var(--map-panel-2,#262628);border-color:var(--map-border,#2b2c33);color:var(--map-ink,#f5f5f8);}
  #podUploadCard .pod-zoom-btn:hover{background:var(--map-panel,#1b1c20);border-color:var(--map-accent,#c03b41);}
  #podUploadCard .pod-upload-btn{background:var(--map-panel-2,#262628);border-color:var(--map-border,#2b2c33);color:var(--map-ink,#f5f5f8);}
  #podUploadCard .pod-upload-btn:hover{background:var(--map-panel,#1b1c20);border-color:var(--map-accent,#c03b41);}
  #podUploadCard .pod-drop{border-color:var(--map-border,#2b2c33);background:var(--map-panel-2,#262628);}
  #podUploadCard .pod-drop.dragover{background:var(--map-panel,#1b1c20);border-color:var(--map-accent,#c03b41);}
  #podUploadCard .btn.full{background:var(--map-accent,#c03b41);border:none;color:#fff;}
  #podUploadCard .btn.full:hover{background:var(--map-accent-dark,#9e2c32);}

  #statusBar{display:flex;gap:24px;align-items:center;padding:6px 16px;background:#fff;border-top:1px solid var(--border);color:#555;font-size:12px}

  #loadingMask{position:absolute;inset:0;background:rgba(255,255,255,.65);display:none;align-items:center;justify-content:center;z-index:6}
  .spinner{width:64px;height:64px;border-radius:50%;border:6px solid rgba(167,11,19,.25);border-top-color:#a70b13;animation:spin 1s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}

  .card{border:1px solid #e1e3e6;border-radius:12px;padding:14px;margin:10px 0;background:#fff;box-shadow:0 2px 10px rgba(16,21,28,.05)}
  .brandbar{display:flex;align-items:center;gap:12px;padding:14px 16px;margin:-14px -14px 14px -14px;color:#fff;background:linear-gradient(90deg,var(--brand),var(--brand2));border-radius:12px 12px 0 0}
  .brandbar img{width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,.6);background:#fff}
  .brandbar h1{margin:0;font-size:18px;font-weight:800;letter-spacing:.2px}
  .brandbar .muted{margin-left:auto;opacity:.95;font-weight:600}

  .rpt-grid{display:grid;grid-template-columns:1fr 1.25fr;gap:18px}
  .propmap{grid-column:1 / -1}
  .propmap-grid{display:grid;grid-template-columns:1fr 1.6fr;gap:16px;align-items:start}
  .badge-pill{display:inline-block;border:1px solid #dadde2;border-radius:999px;padding:4px 10px;margin:4px 6px 0 0;background:#fafbfc}
  .kv{margin-top:8px;font-size:14px;color:#333}.kv div{margin:4px 0}
  img.map{max-width:100%;border:1px solid #e1e3e6;border-radius:10px}

  .section-title{margin:0 0 10px;font-size:18px}
  .overlay-header{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .backbtn{display:inline-block;border:1px solid #d7d7d7;border-radius:999px;padding:6px 10px;font-size:12px;color:#333;text-decoration:none;background:#f7f7f7}
  .backbtn:hover{background:#eee}

  .sumlist{margin:6px 0 0 18px;padding:0}.sumlist li{margin:8px 0 12px}
  .note{margin-top:8px;font-size:13px;color:#7a0f16;font-weight:700}
  .rpt-footer{margin-top:14px;padding-top:8px;border-top:1px dashed #ddd;font-size:12px;color:#555}

  .leg{font-size:13px;line-height:1.35;margin-top:8px}
  .leg .row{display:flex;align-items:center;gap:8px;margin:2px 0}
  .leg .swbox{display:inline-flex;align-items:center;justify-content:center;width:16px;height:14px;padding:1px;border:1px solid #999;border-radius:3px;overflow:hidden;background:#fff}
  .leg .swbox img,.leg .swbox svg,.leg .swbox canvas{width:100%;height:100%;display:block;object-fit:contain}

  @media print{*{-webkit-print-color-adjust:exact!important;print-color-adjust:exact!important}.card{page-break-inside:avoid}}

  #rptOverlay{position:fixed;inset:0;display:none;z-index:9999;background:rgba(246,247,249,.94);backdrop-filter:saturate(1.2) blur(2px);place-items:center;padding:24px}
  #rptCard{width:min(880px,92vw);border:1px solid #e6e8ec;border-radius:16px;background:#fff;box-shadow:0 20px 48px rgba(16,21,28,.12)}
  #rptBrand{display:flex;align-items:center;gap:12px;color:#fff;background:linear-gradient(90deg,#a70b13,#7f0e15);padding:14px 16px;border-radius:16px 16px 0 0}
  #rptBrand img{width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,.6);background:#fff}
  #rptBrand h1{margin:0;font-size:18px;font-weight:800;letter-spacing:.2px}
  #rptBody{padding:16px}
  #rptStatus{display:flex;align-items:center;gap:10px;color:#344054}
  #rptRing{width:22px;height:22px;border:3px solid #e8e8ee;border-top-color:#a70b13;border-radius:50%;animation:spin 1s linear infinite}
  #rptProgress{height:8px;background:#eef0f4;border-radius:999px;overflow:hidden;margin-top:10px}
  #rptBar{height:100%;width:0%;background:linear-gradient(90deg,#a70b13,#df5056);transition:width .25s ease;border-radius:999px}
  #rptSteps{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:12px}
  .rptStep{background:#fbfbfc;border:1px dashed #e2e4e8;border-radius:10px;padding:10px;font-size:12px;color:#475467}
  .rptDone{border-color:#cfe6d2;background:#f2faf3;color:#1e7a31;font-weight:600}

  #sumOverlays{ max-height: 320px; overflow: auto; padding-right: 6px; scrollbar-width: thin; scrollbar-color: #c7cbd1 transparent; }
  #sumOverlays::-webkit-scrollbar{ width: 8px; }
  #sumOverlays::-webkit-scrollbar-thumb{ background:#c7cbd1; border-radius:6px; }
  #sumOverlays::-webkit-scrollbar-track{ background:transparent; }
</style>
<link rel="stylesheet" href="map-theme.css">
</head>
<body>
  <header>
    <div class="brand-logo"><img src="./images/250916 Cornerstone Logo.png" alt="Cornerstone" style="height:64px"></div>
    <div class="toolbar">
      <button id="btnHome" class="btn linklike" title="Back to index">Home</button>
      <button id="btnPrintReport" class="btn">Print Report</button>
    </div>
  </header>

  <main>
    <aside id="left">
      <div class="side-heading">
        <div class="side-heading-title">LOGAN CITY INTERACTIVE MAPPING</div>
      </div>
      <section id="panel-summary" class="panel active" role="tabpanel" aria-labelledby="tab-summary">
        
        <button class="tab" id="tab-summary"  role="tab" aria-selected="true"  aria-controls="panel-summary">Summary</button>
        <div class="card">
          <h2 class="section-title">Property</h2>
          <div class="kv">
            <div><b>Lot/Plan:</b> <span id="sumLot">--</span></div>
            <div><b>Area:</b> <span id="sumArea">-- m2</span></div>
            <div><b>Class:</b> <span id="sumClass">--</span></div>
            <div><b>Address:</b> <span id="sumAddress">--</span></div>
            <div><b>Council:</b> <span id="sumCouncil">Logan City Council</span></div>
          </div>
        </div>
        <div class="card">
          <h2 class="section-title">Overlays</h2>
          <ul id="sumOverlays" class="sumlist"><li><i>Select a parcel...</i></li></ul>
        </div>
        <div class="card" id="podUploadCard">
          <details class="pod-details" id="podDetails">
            <summary>POD Import</summary>
            <p style="margin-top:10px;font-size:13px;color:#4b5563">Upload a POD PDF to auto-detect subdivisions. ArcGIS uploads will be enabled next.</p>
            <form id="podForm" class="pod-form">
              <div class="pod-upload-row pod-drop" id="podDropZone">
                <label for="podFile" class="pod-upload-btn">Choose file</label>
                <div id="podFileName" class="pod-file-name">No file chosen</div>
              </div>
              <input type="file" id="podFile" accept="application/pdf" required>
              <button type="submit" id="podSubmitBtn" class="btn full">Upload & Import</button>
            </form>
            <div id="podStatus" class="pod-status">Select a POD PDF to begin.</div>
            <div id="podResultWrap" class="pod-results" hidden>
              <strong style="font-size:13px;display:block;margin-bottom:4px">Detected Subdivisions</strong>
              <ul id="podResultList"></ul>
            </div>
          </details>
        </div>
      </section>

      <section id="panel-setbacks" class="panel" role="tabpanel" aria-labelledby="tab-setbacks">
        <p>Setback tools are disabled in the Beta build.</p>
      </section>

      <section id="panel-proposal" class="panel" role="tabpanel" aria-labelledby="tab-proposal">
        <p>Proposal drawing is disabled in the Beta build.</p>
      </section>

      <section id="panel-yield" class="panel" role="tabpanel" aria-labelledby="tab-yield">
        <p>Yield calculator is disabled in the Beta build.</p>
      </section>
    </aside>

    <div id="viewWrap">
      <div id="viewDiv"></div>
      <div id="loadingMask"><div class="spinner" aria-label="Loading..."></div></div>
    </div>
  </main>

  <div id="statusBar">
    <span id="statusCoords">Coords: --</span>
    <span id="statusZoom">Zoom: --</span>
    <span id="statusScale">Scale: --</span>
  </div>

  <div id="rptOverlay" aria-hidden="true">
    <div id="rptCard">
      <div id="rptBrand">
        <img src="./images/Flavour icon.png" alt="Logo">
        <h1>LOGAN CITY INTERACTIVE MAPPING - GENERATING REPORT</h1>
      </div>
      <div id="rptBody">
  <div id="rptStatus"><div id="rptRing"></div><div id="rptMsg">Starting...</div></div>
  <div id="rptProgress"><div id="rptBar"></div></div>
  <div id="rptSteps">
    <div class="rptStep" id="rptS1">Locate parcel</div>
    <div class="rptStep" id="rptS2">Resolve address</div>
    <div class="rptStep" id="rptS3">Render overlays</div>
    <div class="rptStep" id="rptS4">Compose document</div>
  </div>
  <div style="margin-top:10px;color:#667085;font-size:12px">Keep this tab visible while the report builds so map screenshots can render smoothly.</div>
</div>
  </div>
</div>
  </div>

  <script type="module">
    /* ---------------- ArcGIS imports ---------------- */
    import Portal from "https://js.arcgis.com/4.30/@arcgis/core/portal/Portal.js";
    import WebMap from "https://js.arcgis.com/4.30/@arcgis/core/WebMap.js";
    import MapView from "https://js.arcgis.com/4.30/@arcgis/core/views/MapView.js";
    import Graphic from "https://js.arcgis.com/4.30/@arcgis/core/Graphic.js";
    import GraphicsLayer from "https://js.arcgis.com/4.30/@arcgis/core/layers/GraphicsLayer.js";
    import Search from "https://js.arcgis.com/4.30/@arcgis/core/widgets/Search.js";
    import Expand from "https://js.arcgis.com/4.30/@arcgis/core/widgets/Expand.js";
    import ScaleBar from "https://js.arcgis.com/4.30/@arcgis/core/widgets/ScaleBar.js";
    import Home from "https://js.arcgis.com/4.30/@arcgis/core/widgets/Home.js";
    import LayerList from "https://js.arcgis.com/4.30/@arcgis/core/widgets/LayerList.js";
    import Legend from "https://js.arcgis.com/4.30/@arcgis/core/widgets/Legend.js";
    import BasemapGallery from "https://js.arcgis.com/4.30/@arcgis/core/widgets/BasemapGallery.js";
    import Fullscreen from "https://js.arcgis.com/4.30/@arcgis/core/widgets/Fullscreen.js";
    import * as reactiveUtils from "https://js.arcgis.com/4.30/@arcgis/core/core/reactiveUtils.js";
    import * as geometryEngine from "https://js.arcgis.com/4.30/@arcgis/core/geometry/geometryEngine.js";
    import * as symbolUtils from "https://js.arcgis.com/4.30/@arcgis/core/symbols/support/symbolUtils.js";
    import * as locator from "https://js.arcgis.com/4.30/@arcgis/core/rest/locator.js";
    import esriConfig from "https://js.arcgis.com/4.30/@arcgis/core/config.js";

    /* ---------------- Tunables ---------------- */
    const TOUCH_BUFFER_M = 6;
    const SWATCH_PX = 16;
    const GEOCODER_URL = "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer";
    const LOGAN=[153.1024711187046,-27.76239839483306]; // Provided center
    const START_SCALE = 36111.909643; // Provided scale
    const M2="m2";
    const HOUSES_OUT = 3;
    const HOUSE_LOT_METERS = 25;
    const SCREEN_BUFFER_METERS = HOUSES_OUT * HOUSE_LOT_METERS;
    const SHOT_SIZE = { width: 1280, height: 900 };
    const LOTPLAN_FALLBACK_URLS = [
      "https://spatial-gis.information.qld.gov.au/arcgis/rest/services/PlanningCadastre/LandParcelPropertyFramework/MapServer/0",
      "https://spatial-gis.information.qld.gov.au/arcgis/rest/services/PlanningCadastre/LandParcelPropertyFramework/MapServer/4",
      "https://services2.arcgis.com/dEKgZETqwmDAh1rP/arcgis/rest/services/property_boundaries_parcel/FeatureServer/0",
      "https://services2.arcgis.com/dEKgZETqwmDAh1rP/arcgis/rest/services/property_boundaries_holding/FeatureServer/0",
      "https://spatial-gis.information.qld.gov.au/arcgis/rest/services/Property/PropertyBoundaries/MapServer/0"
    ];

    /* ---- CORS allow-list for address queries ---- */
    (function(){
      var hosts = [
        "cornerstonebc.maps.arcgis.com",
        "services.arcgis.com",
        "services2.arcgis.com",
        "gisservices.information.qld.gov.au",
        "spatial-gis.information.qld.gov.au",
        "gis.brisbane.qld.gov.au",
        "maps.moretonbay.qld.gov.au",
        "maps.logan.qld.gov.au"
      ];
      try{
        var arr = esriConfig.request.corsEnabledServers;
        for (var i=0;i<hosts.length;i++){
          var h = hosts[i];
          if (arr.indexOf(h) === -1) arr.push(h);
        }
      }catch(e){}
    })();

    /* ---------------- Small helpers ---------------- */
    const $=function(id){ return document.getElementById(id); };
    const setText=function(id,t){ var el=$(id); if(el) el.textContent=t; };
    const showLoading=function(on){ var m=$("loadingMask"); if(m) m.style.display=on?"flex":"none"; };
    const raf=function(){ return new Promise(function(r){ requestAnimationFrame(function(){ r(); }); }); };
    const sleep=function(ms){ return new Promise(function(r){ setTimeout(r,ms); }); };
    const waitViewIdle=async function(extra){ extra = (typeof extra==="number")?extra:240; try{ await reactiveUtils.whenOnce(function(){ return !view.updating; }); }catch(e){} await raf(); await sleep(extra); };
    const slug=function(s){ s=String(s||"overlay").toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,""); return s; };
    const htmlEsc=function(s){ s=String((s===undefined||s===null)?"":s); return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;"); };
    const attrEsc=function(s){ s=String((s===undefined||s===null)?"":s); return s.replace(/&/g,"&amp;").replace(/"/g,"&quot;"); };
    const valOr=function(v,def){ return (v===undefined||v===null)?def:v; };
    const PDF_WORKER_SRC="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    if(window.pdfjsLib){
      try{
        window.pdfjsLib.GlobalWorkerOptions.workerSrc=PDF_WORKER_SRC;
      }catch(e){ console.warn("pdfjs worker init failed",e); }
    }else{
      console.warn("pdf.js library failed to load; POD detection disabled.");
    }
    async function extractPdfText(file){
      if(!file) throw new Error("No file selected");
      if(!window.pdfjsLib) throw new Error("PDF parser not available");
      const buffer = await file.arrayBuffer();
      const pdf = await window.pdfjsLib.getDocument({data:buffer}).promise;
      let text="";
      for(var i=1;i<=pdf.numPages;i++){
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        const strings = content.items.map(function(item){ return item.str||""; }).filter(Boolean);
        text += strings.join(" ") + "\\n";
      }
      return text;
    }
        function parseSubdivisionsFromText(text){
      if(!text) return [];
      const lines = text.split(/\r?\n/).map(function(t){ return t.trim(); }).filter(Boolean);
      const subdivisions=[];
      const planRegex=/\b((?:SP|RP|CP|BUP|SL|DP|SPRP)\s*-?\s*\d+)\b/i;
      const planLooseRegex=/((?:SP|RP|CP|BUP|SL|DP|SPRP)\s*-?\s*\d+)/i;
      const lotRegex=/\b(?:lot|lot\s*no\.?)\s*[:#-]?\s*([0-9A-Za-z-]+)\b/i;
      const comboRegex=/(\d+[A-Za-z-]?)(?:\s*(?:\/|on)\s*|\s*)((?:SP|RP|CP|BUP|SL|DP|SPRP)\s*-?\s*\d+)/i;
      const areaRegex=/(\d{1,3}(?:,\d{3})*(?:\.\d+)?)\s*(?:m2|sqm|square metres?)/i;

      const globalLotPlan=[...text.matchAll(/\bLot\s+(\d+[A-Za-z-]?)\s+on\s+((?:SP|RP|CP|BUP|SL|DP|SPRP)\s*-?\s*\d+)\b/ig)];
      globalLotPlan.forEach(function(m){
        const lot = m[1];
        const plan = m[2].replace(/[\s-]+/g,"").toUpperCase();
        const key=lot+"_"+plan;
        if(!subdivisions.some(function(sub){ return (sub.lot+"_"+sub.plan)===key; })){
          subdivisions.push({lot:lot,plan:plan,areaSqm:null,raw:m[0]});
        }
      });
      const globalCombos=[...text.matchAll(/\b(\d+[A-Za-z-]?)\s*(?:\/|on)?\s*((?:SP|RP|CP|BUP|SL|DP|SPRP)\s*-?\s*\d+)\b/ig)];
      globalCombos.forEach(function(m){
        const lot=m[1];
        const plan=m[2].replace(/[\s-]+/g,"").toUpperCase();
        const key=lot+"_"+plan;
        if(!subdivisions.some(function(sub){ return (sub.lot+"_"+sub.plan)===key; })){
          subdivisions.push({lot:lot,plan:plan,areaSqm:null,raw:m[0]});
        }
      });

      let current=null;
      const pushCurrent=function(){
        if(!current) return;
        if(!current.lot && !current.plan) return;
        if(typeof current.areaSqm!=="number"||!isFinite(current.areaSqm)){
          current.areaSqm=null;
        }
        const key=(current.lot||"")+"_"+(current.plan||"");
        if(!subdivisions.some(function(sub){ return (sub.lot+"_"+sub.plan)===key; })){
          subdivisions.push({
            lot:current.lot||null,
            plan:current.plan||null,
            areaSqm:current.areaSqm,
            raw:current.raw
          });
        }
      };

      for(var idx=0; idx<lines.length; idx++){
        const line=lines[idx];
        const normalized=line.replace(/\s+/g," ");
        const lotMatch=normalized.match(lotRegex);
        var planMatch=normalized.match(planRegex);
        if(!planMatch) planMatch=normalized.match(planLooseRegex);
        const comboMatch=normalized.match(comboRegex);
        const areaMatch=normalized.match(areaRegex);

        var candidateLot=null;
        var candidatePlan=null;
        if(comboMatch){
          candidateLot=comboMatch[1].toUpperCase();
          candidatePlan=comboMatch[2].replace(/[\s-]+/g,"").toUpperCase();
        }
        if(lotMatch){
          candidateLot=lotMatch[1].toUpperCase();
        }
        if(planMatch){
          candidatePlan=planMatch[1].replace(/[\s-]+/g,"").toUpperCase();
          if(!candidateLot && typeof planMatch.index==="number"){
            const prefix=normalized.slice(0, planMatch.index).trim();
            const inline=prefix.match(/(\d+[A-Za-z-]?)/);
            if(inline) candidateLot=inline[1].toUpperCase();
          }
        }

        const shouldStartNew=!current||
          (candidateLot&&current.lot&&candidateLot!==current.lot)||
          (candidatePlan&&current.plan&&candidatePlan!==current.plan);

        if(shouldStartNew){
          pushCurrent();
          current={lot:null,plan:null,areaSqm:null,raw:normalized};
        }else if(current){
          current.raw=normalized;
        }else{
          current={lot:null,plan:null,areaSqm:null,raw:normalized};
        }

        if(candidateLot){
          current.lot=candidateLot;
        }
        if(candidatePlan){
          current.plan=candidatePlan;
        }
        if(areaMatch){
          const parsed=parseFloat(areaMatch[1].replace(/,/g,""));
          if(!isNaN(parsed)){
            current.areaSqm=parsed;
          }
        }
      }
      pushCurrent();
      return subdivisions;
    }
function framedExtent(geom){
      try{
        var b=geometryEngine.buffer(geom,SCREEN_BUFFER_METERS,"meters");
        return (b&&b.extent)?b.extent:(geom&&geom.extent);
      }catch(e){ return geom && geom.extent; }
    }
    async function withViewOnGeom(geom,fn){
      var vp = (view.viewpoint && typeof view.viewpoint.clone==="function") ? view.viewpoint.clone() : null;
      try{
        if(geom && geom.extent){
          var target=framedExtent(geom);
          await view.goTo(target,{animate:false});
          await waitViewIdle(260);
        }
        return await fn();
      } finally {
        if(vp){ try{ await view.goTo(vp,{animate:false}); await waitViewIdle(160);}catch(e){} }
      }
    }
    const centroidOf = function(g){
      try{
        if (g && g.centroid) return g.centroid;
        if (g && g.extent && g.extent.center) return g.extent.center;
      }catch(e){}
      return null;
    };
    const projectToViewSR=function(geom){
      try{
        if(!geom || !view || !view.spatialReference) return geom;
        if(!geom.spatialReference){
          geom.spatialReference = { wkid: 102100 };
        }
        const gSR = (geom.spatialReference && (geom.spatialReference.wkid||geom.spatialReference.latestWkid));
        const vSR = (view.spatialReference && (view.spatialReference.wkid||view.spatialReference.latestWkid));
        if(gSR && vSR && gSR===vSR) return geom;
        const proj = geometryEngine.project(geom, view.spatialReference);
        return proj || geom;
      }catch(e){ return geom; }
    };
    function normalizeToWebMercator(geom){
      try{
        if(!geom) return geom;
        const sr = (geom.spatialReference && (geom.spatialReference.wkid||geom.spatialReference.latestWkid));
        if(sr===102100 || sr===3857) return geom;
        const sample = geom.type==="point" ? geom :
          geom.type==="polyline" ? (geom.paths && geom.paths[0] && geom.paths[0][0]) :
          geom.type==="polygon" ? (geom.rings && geom.rings[0] && geom.rings[0][0]) : null;
        if(sample){
          const x = sample.x!=null ? sample.x : sample[0];
          const y = sample.y!=null ? sample.y : sample[1];
          if(Math.abs(x)>180 || Math.abs(y)>90){
            geom.spatialReference = { wkid:102100 };
            return geom;
          }
        }
        const projected = geometryEngine.project(geom, {wkid:102100});
        return projected || geom;
      }catch(e){ return geom; }
    }

    /* ---------------- Map & rules ---------------- */
    const portal=new Portal({url:"https://cornerstonebc.maps.arcgis.com"});
    // Use Logan WebMap item id
    let webmap=new WebMap({portalItem:{id:"e58a1a64e2e747cbb667ffd0b4e01b33",portal:portal}});
    const selLayer=new GraphicsLayer({listMode:"hide"}); webmap.add(selLayer);
    // Use provided center/scale
    const view=new MapView({container:"viewDiv",map:webmap,center:LOGAN,scale:START_SCALE,constraints:{snapToZoom:false}});

    const inText=function(t,p){ return String(t||"")+" "+String(p||""); };
    const isDNT=function(title,id,tags){
      title=String(title||""); id=String(id||""); tags=(tags||[]).join("|");
      return /do[\s-]*not[\s-]*touch/i.test(title) || /do[\s-]*not[\s-]*touch/i.test(id) || /do[\s-]*not[\s-]*touch/i.test(tags);
    };
    const isUtility=function(title,id,tags){ return /\b(utilit(y|ies)|power|electric|telecom|gas|water|sewer|storm[-\s]?water|reticulation|service)\b/i.test(inText(title,id)+" "+(tags||[]).join(" ")); };
    const isWaterOrSewer=function(path){ return /\b(water|sewer|storm[\s-]*water|drainage|watercourse)\b/i.test(String(path||"")); };
    const isAcid=function(t,p){ return /\bacid\b/i.test(inText(t,p)); };
      const isTransport=function(t,p){
        const hay=inText(t,p);
        if(/\b(transport|road|rail|traffic|cycle|bikeway|pedestrian|carpark|parking|transit|bus|ferry)\b/i.test(hay)) return true;
        if(/\bcorridor\b/i.test(hay) && !/\b(water|waterway|wetland|bio|biodiversity|habitat|conservation|vegetation|riparian|environment|green)\b/i.test(hay)) return true;
        return false;
      };
    const isAir=function(t,p){ return /\b(air\s*quality|air-quality|air|pollution)\b/i.test(inText(t,p)); };
    const isNoise=function(t,p){ return /\b(noise|acoustic|transport.*noise.*corridor|tnc)\b/i.test(inText(t,p)); };
    const isZoning=function(t,p){ return /\b(zoning|zone|zones)\b/i.test(inText(t,p)); };
    const isBushfire=function(t,p){ return /\b(bush[-\s]?fire|bushfire|bush\s*fire|wild[-\s]?fire|fire\s*hazard)\b/i.test(inText(t,p)); };

    function kidsOf(n){
      var arr=null;
      if(n && n.layers){ arr = (n.layers && typeof n.layers.toArray==="function") ? n.layers.toArray() : n.layers; }
      if(!arr && n && n.sublayers){ arr = (n.sublayers && typeof n.sublayers.toArray==="function") ? n.sublayers.toArray() : n.sublayers; }
      return arr || [];
    }
    function nodePath(n){
      var bits=[], cur=n;
      while(cur){ bits.unshift(cur.title||cur.id||"node"); cur=cur.parent; }
      return bits.join(" / ");
    }

    function walkAny(node,cb,inheritedDNT){
      if(!node) return;
      inheritedDNT = !!inheritedDNT;
      var t=node.title||node.id||"", id=node.id||"", tg=(node.portalItem && node.portalItem.tags) || [];
      var flag=inheritedDNT||isDNT(t,id,tg);
      cb(node,flag);
      var kids = kidsOf(node);
      for(var i=0;i<kids.length;i++){ walkAny(kids[i],cb,flag); }
    }
    function keepOnHidden(node){
      if("visible" in node){ try{ node.visible=true; }catch(e){} }
      if("listMode" in node){ try{ node.listMode="hide"; }catch(e){} }
      try{ node.minScale=0; node.maxScale=0; }catch(e){}
      if(node.type==="sublayer"){ try{ node.updateFromJSON({minScale:0,maxScale:0}); }catch(e){} }
      var p=node.parent;
      while(p){ if("visible" in p){ try{ p.visible=true; }catch(e){} } p=p.parent; }
    }
    function startHidden(node){
      if("visible" in node){ try{ node.visible=false; }catch(e){} }
      if("listMode" in node){ try{ node.listMode="show"; }catch(e){} }
    }
    function enforceOverlayRules(){
      walkAny(webmap,function(node,underDNT){
        if(node.type==="graphics"){ try{node.listMode="hide";}catch(e){} return; }
        if(!("visible" in node)) return;
        if(underDNT) keepOnHidden(node); else startHidden(node);
      });
    }
    ;[300,900,1800,3500].forEach(function(ms){ setTimeout(function(){ try{enforceOverlayRules();}catch(e){} },ms); });
    (async function(){ showLoading(true); try{ await webmap.loadAll(); enforceOverlayRules(); }catch(e){ console.warn("WebMap auth/fail; fallback basemap",e); webmap=new WebMap({basemap:"streets-vector"}); webmap.add(selLayer); view.map=webmap; } finally{ showLoading(false);} })();

    view.ui.add(new Home({view:view}),"top-left");
    view.ui.add(new ScaleBar({view:view,unit:"metric"}),"bottom-left");
    const layerList=new LayerList({view:view,listItemCreatedFunction:function(e){
      const item=e.item, node=item.sublayer||item.layer;
      if(!node) return;
      if(node.type==="graphics"){ item.visible=false; item.panel=null; try{node.listMode="hide";}catch(e){} return; }
      let cur=node, inDNT=false;
      while(cur){
        const t=cur.title||"", i=cur.id||"", tg=(cur.portalItem&&cur.portalItem.tags)||[];
        if(isDNT(t,i,tg)){ inDNT=true; break; }
        cur=cur.parent;
      }
      if(inDNT){ keepOnHidden(node); item.visible=false; item.panel=null; }
      else{ try{node.listMode="show";}catch(e){} item.visible=true; item.panel={content:"legend"}; }
    }});
    view.ui.add(new Expand({view:view,content:layerList,expandIconClass:"esri-icon-layers",expanded:false}),"top-right");
    view.ui.add(new Expand({view:view,content:new Legend({view:view}),expandIconClass:"esri-icon-legend"}),"top-right");
    view.ui.add(new Expand({view:view,content:new BasemapGallery({view:view}),expandIconClass:"esri-icon-basemap"}),"top-right");
    view.ui.add(new Fullscreen({view:view}),"top-right");

    /* --- Search widget (address + Lot/Plan) --- */
    const search=new Search({
      view:view,
      includeDefaultSources:true,
      popupEnabled:true,
      allPlaceholder:"Search address or Lot/Plan (e.g., 12/SP12345)"
    });
    view.ui.add(search,{position:"top-right",index:0});

    /* ---------------- Status ---------------- */
    view.watch("extent",function(){
      var c=view.center;
      setText("statusCoords","Coords: " + c.longitude.toFixed(5) + ", " + c.latitude.toFixed(5));
      setText("statusZoom","Zoom: " + view.zoom.toFixed(1));
      setText("statusScale","Scale: 1:" + Math.round(view.scale));
    });

    /* ---------------- Parcel selection ---------------- */
    const parseNumberLike=function(raw){
      if(raw==null) return null;
      var s=String(raw).trim(); if(!s) return null;
      var hasHA=/(^|[^a-z])ha([^a-z]|$)/i.test(s)||/\bhectare(s)?\b/i.test(s);
      s=s.replace(/,/g,"").replace(/square\s*met(re|er)s?/ig,"").replace(/m2|m\u00B2|sqm|sq\.?m/ig,"").trim();
      var n=parseFloat(s); if(isNaN(n)) return null;
      if(hasHA) n*=10000; return n;
    };
    function getLotAreaSqm(attrs){
      const strong=["LOT_AREA_M2","LOT_SIZE_M2","LOT_SIZE_SQM","LOT_AREA_SQM","AREA_SQM","SITE_AREA_SQM","LAND_AREA_SQM","LOT_AREA","LOT_SIZE","SITE_AREA","LAND_AREA","AREA_M2","AREA (M2)","AREA(M2)","AREA_M^2","AREA_HA","HECTARES"];
      for(var i=0;i<strong.length;i++){
        var k=strong[i];
        var v=(k in attrs)?parseNumberLike(attrs[k]):null;
        if(v!=null){
          if(v>0&&v<50&&(k==="AREA_HA"||k==="HECTARES")) return v*10000;
          return v;
        }
      }
      for(var k2 in attrs){
        var v2=attrs[k2];
        if(/(lot|site|land).*area/i.test(k2)||/area.*(sqm|m2|m\^2|square)/i.test(k2)||(/(lot|site).*size/i.test(k2))){
          var val=parseNumberLike(v2); if(val) return val;
        }
      }
      return null;
    }
    function parseParcelMeta(attrs){
      const keys=function(rx){ for(var k in attrs){ if(rx.test(k)) return k; } return null; };
      const lot=attrs["LOT"]||attrs["LOTNO"]||attrs["LOT_NO"]||attrs["LOTNUMBER"]||(keys(/^lot[\w_]*$/i)?String(attrs[keys(/^lot[\w_]*$/i)]):null);
      const plan=attrs["PLAN"]||attrs["PLANNO"]||attrs["PLAN_NO"]||(keys(/^plan[\w_]*$/i)?String(attrs[keys(/^plan[\w_]*$/i)]):null);
      let lotplan=attrs["LOT_PLAN"]||attrs["LOT_PLAN_NO"]||attrs["LOTPLAN"]||attrs["LOTPLAN_NO"]||attrs["LOTPLAN_TXT"]||attrs["LOT_PLAN_TXT"]||attrs["LOT_PLAN_TEXT"]||attrs["LOTPLAN_TEXT"];
      if(!lotplan && lot && plan) lotplan=lot+"/"+plan;
      if(!lotplan){
        for(var key in attrs){
          var s=String(attrs[key]||"").toUpperCase();
          var m=s.match(/\b(\d+)\s*\/\s*([A-Z]{1,4}\s*\d{1,8})\b/);
          if(m){ lotplan=m[1]+"/"+m[2].replace(/\s+/g,""); break; }
        }
      }
      return {lot:lot,plan:plan,lotplan:lotplan};
    }
    const geomAreaSqmSafe=function(g){ try{ var a=Math.abs(geometryEngine.planarArea(g,"square-meters")||0); return a>0?a:null; }catch(e){ return null; } };

    function smartJoin(parts){
      var out=[];
      for(var i=0;i<parts.length;i++){ if(parts[i]) out.push(parts[i]); }
      return out.join(" ").replace(/\s+/g," ").trim();
    }
    const _get=function(o,ks){ for(var i=0;i<ks.length;i++){ var k=ks[i]; if(k in o && String(valOr(o[k],"")).trim()) return String(o[k]).trim(); } return null; };

    function parseCouncil(attrs){
      if(!attrs) return null;
      const first=function(){
        for(var i=0;i<arguments.length;i++){
          var k=arguments[i];
          if(k in attrs){ var v=String(attrs[k]||"").trim(); if(v) return v; }
        }
        return null;
      };
      return first("COUNCIL","COUNCIL_NAME","LGA","LGA_NAME","LOCAL_GOVERNMENT_AREA","AUTHORITY","ADMIN_BODY") || "Logan City Council";
    }

    const ADDR_DEBUG=false;

    const FULL_ADDR_FIELDS = [
      "FULL_ADDRESS","ADDRESS_FULL","GNAF_FULL_ADDRESS","GNAF_ADDRESS",
      "SITE_ADDRESS","PROPERTY_ADDRESS","PROP_ADDRESS","PRIMARY_ADDRESS",
      "ADDR_FULL","ADDR_LABEL","ADDRESS","STREET_ADDRESS","POSTAL_ADDRESS",
      "FULLADDR","FULL_ADD","FULL_ADDRE","SITE_ADDR","SITE_ADD","PROP_ADD",
      "PROPERTY_ADDR","PROPERTY_ADD","ADDRESS1","ADDRESS_1","ADDR1"
    ];

    const PART_FIELDS = {
      unit:  ["UNIT_NO","UNIT_NUMBER","UNIT","APARTMENT","FLAT","SUITE","SUB_UNIT","APT","FLAT_NO","UNITNO","UNITNUM"],
      numP:  ["HOUSE_PREFIX","NUMBER_PREFIX","ADDR_NUM_PREFIX","NUMBER_PRE","NO_PRE","HSE_PRE"],
      num:   ["HOUSE_NO","HOUSE_NUMBER","STREET_NO","STREET_NUMBER","PRIMARY_NO","PROPERTY_NO","NUMBER","HSE_NO","HSE_NUM","ADDR_NO"],
      numS:  ["HOUSE_SUFFIX","NUMBER_SUFFIX","ADDR_NUM_SUFFIX","NUMBER_SUF","NO_SUF","HSE_SUF"],
      stNm:  ["STREET_NAME","ST_NAME","ROAD_NAME","RD_NAME","ADD_STREET_NAME","STREET","ST_NAM","RD_NAM"],
      stTp:  ["STREET_TYPE","ST_TYPE","ROAD_TYPE","RD_TYPE","ADDR_TYPE","ST_TYP","RD_TYP"],
      stSf:  ["STREET_SUFFIX","ST_SUFFIX","ROAD_SUFFIX","RD_SUFFIX","ST_SUF","RD_SUF"],
      suburb:["SUBURB","SUBURB_NAME","LOCALITY","LOCALITY_NAME","TOWN","CITY","SUB_NAME","LOCALITY_N"],
      state: ["STATE","STATE_ABBR","STATE_CODE"],
      post:  ["POSTCODE","POST_CODE","ZIP","PSTCODE","PST_CD"]
    };

    function _pick(attrs, keys){
      for(var i=0;i<keys.length;i++){
        var k=keys[i];
        if(k in attrs){
          var v = String(valOr(attrs[k],"")).trim();
          if(v && v.toUpperCase()!=="NULL") return v;
        }
      }
      return null;
    }
    const _smartJoin = smartJoin;

    function buildAddressFromParts(attrs){
      const unit=_pick(attrs,PART_FIELDS.unit);
      const numP=_pick(attrs,PART_FIELDS.numP);
      const num =_pick(attrs,PART_FIELDS.num);
      const numS=_pick(attrs,PART_FIELDS.numS);
      const stNm=_pick(attrs,PART_FIELDS.stNm);
      const stTp=_pick(attrs,PART_FIELDS.stTp);
      const stSf=_pick(attrs,PART_FIELDS.stSf);
      const suburb=_pick(attrs,PART_FIELDS.suburb);
      const state  = _pick(attrs,PART_FIELDS.state) || "QLD";
      const post   = _pick(attrs,PART_FIELDS.post);

      const line1=_smartJoin([ unit ? (unit+"/") : null, _smartJoin([numP,num,numS]), _smartJoin([stNm,stTp,stSf]) ]);
      const line2=_smartJoin([ suburb, state, post ]);
      return _smartJoin([line1,line2]) || null;
    }

    function parseAddress(attrs){
      if(!attrs) return null;
      for(var i=0;i<FULL_ADDR_FIELDS.length;i++){
        var f = FULL_ADDR_FIELDS[i], v = attrs[f];
        if(v!=null){
          var s = String(v).trim();
          if(s && s.toUpperCase()!=="NULL") return s;
        }
      }
      const candidates=["LOT_PLAN","LOT_PLAN_NO","LOTPLAN","LOTPLAN_NO","LOTPLAN_TXT","LOT_PLAN_TXT","LOT_PLAN_TEXT","LOTPLAN_TEXT"];
      for(var j=0;j<candidates.length;j++){
        var s2 = String(valOr(attrs[candidates[j]],"")).trim();
        if(/\d{1,5}\s+[A-Za-z].*\d{4}\b/.test(s2)) return s2;
      }
      const built = buildAddressFromParts(attrs);
      if(built) return built;
      for(var k in attrs){
        var v2 = String(valOr(attrs[k],"")).trim();
        if(!v2) continue;
        var m=v2.match(/\b\d{1,5}\s+[A-Za-z][A-Za-z\s.'-]+(?:\b(St|Street|Rd|Road|Ave|Avenue|Dr|Drive|Cres|Court|Ct|Lane|Ln|Terrace|Ter|Way|Pde|Parade)\b)[^,;]*?(?:,\s*[A-Za-z][A-Za-z\s.'-]+)?(?:\s+(?:QLD|Queensland))?\s*\d{4}\b/i);
        if(m) return m[0].replace(/\s+/g," ").trim();
      }
      return null;
    }

    /* ===== SAFE VERSION: ensure suburb appended (no template literals/optional chaining) ===== */
    function ensureSuburbInAddress(addr, attrs){
      if(!addr) return addr;

      const _p = function(obj, keys){
        for (var i=0;i<keys.length;i++){
          var k = keys[i];
          if (k in obj){
            var v = String(valOr(obj[k],"")).trim();
            if (v && v.toUpperCase() !== "NULL") return v;
          }
        }
        return null;
      };

      const suburb = _p(attrs||{}, PART_FIELDS.suburb);
      const state  = _p(attrs||{}, PART_FIELDS.state) || "QLD";
      const post   = _p(attrs||{}, PART_FIELDS.post);

      if(!suburb) return addr;

      const norm = function(s){ return String(s||"").toUpperCase().replace(/[, \s]+/g," ").trim(); };
      if (norm(addr).includes(norm(suburb))) return addr;

      const reEscape = function(s){ return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); };
      const postRx   = post ? "\\b" + reEscape(post) + "\\b" : "";
      const pat      = "(?:,\\s*)?(?:QLD|Queensland)\\s*" + postRx + "\\s*$";
      const rxTail   = new RegExp(pat, "i");

      const tailWanted = suburb + " " + state + (post ? " " + post : "");

      if (rxTail.test(addr)){
        return addr.replace(rxTail, ", " + tailWanted);
      }
      return addr.replace(/\s+,/g, ",") + ", " + tailWanted;
    }

    function looksLikeAddressLayer(node){
      const hay = (String(node.title||"")+" "+nodePath(node)).toLowerCase();
      return /\b(gnaf|address|addr|property\s*address|site\s*address|street\s*address|address\s*points|locality|suburb|road\s*centerline|road\s*centreline)\b/.test(hay);
    }

    function flattenFeatureNodes(){
      const out=[];
      walkAny(view.map,function(n){
        if(n && (n.type==="feature"||n.type==="sublayer") &&
           (typeof n.queryFeatures==="function" || typeof n.queryFeatureCount==="function")) out.push(n);
      });
      return out;
    }
    const PARCEL_FIELD_RX=/\b(LOT(?:_?PLAN)?|LOTNO|LOT_NO|LOTNUMBER|LOT_NUM|LOTNUM|PLAN|PLAN_NO|PLANNO|LOT_PLAN|LOTPLAN|LOT_PLAN_TXT|LOTPLAN_TXT|PARCEL|PARCEL_ID|PROP(?:ERTY)?_?ID?)\b/i;
    function hasParcelFields(node){
      try{
        const flds=node.fields||[];
        for(let i=0;i<flds.length;i++){
          if(PARCEL_FIELD_RX.test(String(flds[i].name||""))) return true;
        }
      }catch(e){}
      return false;
    }
    const looksLikeParcelLayer=function(node){
      const hay=((node.title||"")+" "+nodePath(node)+" "+(node.url||"")).toLowerCase();
      return /(cadast|parcel|dcdb|lot|property)/i.test(hay);
    };

    async function scanAddressLayers(lotGeom){
      const nodes = flattenFeatureNodes().filter(function(n){ try{ return looksLikeAddressLayer(n); }catch(e){return false;} });
      const centroid = centroidOf(lotGeom);
      const candidates = [];

      for(var i=0;i<nodes.length;i++){
        const n=nodes[i];
        try{
          await n.load();
          const outFields = ["*"];

          const r1 = await n.queryFeatures({
            geometry: lotGeom, spatialRelationship: "intersects",
            returnGeometry: false, outFields: outFields, maxRecordCountFactor: 3
          });
          (r1.features||[]).forEach(function(f){
            const addr = parseAddress(f.attributes);
            if(addr) candidates.push({addr:addr, score:3, layer:n});
          });

          if(centroid){
            const r2 = await n.queryFeatures({
              geometry: centroid, distance: 40, units: "meters",
              spatialRelationship: "intersects", returnGeometry: false,
              outFields: outFields, maxRecordCountFactor: 3
            });
            (r2.features||[]).forEach(function(f){
              const addr = parseAddress(f.attributes);
              if(addr) candidates.push({addr:addr, score:2, layer:n});
            });
          }
        }catch(e){
          if(ADDR_DEBUG) console.warn("Address layer failed:", n.title, e);
        }
      }

      candidates.sort(function(a,b){
        return (b.score-a.score) ||
               (((/\d/.test(b.addr)?1:0)-(/\d/.test(a.addr)?1:0))) ||
               (b.addr.length-a.addr.length);
      });
      return candidates.length ? candidates[0].addr : null;
    }

    async function resolveBestAddress(geom, parcelFeature){
      let attrs = parcelFeature ? (parcelFeature.attributes||{}) : null;
      let addr = attrs ? parseAddress(attrs) : null;
      const weak = !addr || addr.trim().length<=4 || /^[A-Z]{2,3}$/.test(addr.trim());

      if(weak){
        try{
          const fromLayers = await scanAddressLayers(geom);
          if(fromLayers) addr = fromLayers;
        }catch(e){
          if(ADDR_DEBUG) console.warn("scanAddressLayers error:", e);
        }
      }

      if(!addr || addr.trim().length<=4){
        try{
          const cen = centroidOf(geom);
          if(cen){
            const res = await locator.locationToAddress(GEOCODER_URL,{location:cen});
            addr = (res && (res.address || (res.attributes && (res.attributes.Match_addr || res.attributes.LongLabel || res.attributes.Address)))) || addr;
          }
        }catch(e){
          if(ADDR_DEBUG) console.warn("reverse geocode failed:", e);
        }
      }

      addr = ensureSuburbInAddress(addr, attrs || {});
      return addr || "Address unavailable";
    }

    async function findParcelAtPoint(point){
      const all=flattenFeatureNodes();
      const pref=[],rest=[];
      for(var i=0;i<all.length;i++){
        var n=all[i];
        try{
          await n.load();
          if(n.geometryType!=="polygon") continue;
          (looksLikeParcelLayer(n)||hasParcelFields(n)?pref:rest).push(n);
        }catch(e){}
      }
      const layers=pref.concat(rest);
      const collect=async function(opts){
        const out=[];
        for(var i=0;i<layers.length;i++){
          const L=layers[i];
          try{
            const qOpts = Object.assign({}, opts, {returnGeometry:true,outFields:["*"],maxRecordCountFactor:2});
            const r=await L.queryFeatures(qOpts);
            (r.features||[]).forEach(function(f){ out.push({layer:L,feature:f}); });
          }catch(e){}
        }
        return out;
      };
      let cand=await collect({geometry:point,spatialRelationship:"intersects"});
      let contains=cand.filter(function(x){ try{ return geometryEngine.contains(x.feature.geometry,point); }catch(e){ return false; } });
      if(contains.length){
        let best=contains[0], bestD=Infinity;
        for(var i=0;i<contains.length;i++){
          const c=contains[i];
          let d=Infinity; try{ const cen=centroidOf(c.feature.geometry); d=geometryEngine.distance(point,cen)||Infinity; }catch(e){}
          if(d<bestD){ best=c; bestD=d; }
        }
        return best.feature;
      }
      cand=await collect({geometry:point,distance:1.5,units:"meters",spatialRelationship:"intersects"});
      if(cand.length){
        let best=cand[0], bestD=Infinity;
        for(var j=0;j<cand.length;j++){
          const c2=cand[j];
          let d2=Infinity; try{ const near=geometryEngine.nearestCoordinate(c2.feature.geometry,point); d2=(near && near.distance)||Infinity; }catch(e){}
          if(d2<bestD){ best=c2; bestD=d2; }
        }
        return best.feature;
      }
      return null;
    }

    var lastParcelInfo={feature:null,lotText:"--",areaText:"-- "+M2,classText:"--",addressText:"--",councilText:"Logan City Council"};

    function updateSummaryPanel(){
      setText("sumLot", lastParcelInfo.lotText || "--");
      setText("sumArea", lastParcelInfo.areaText || ("-- "+M2));
      setText("sumClass", lastParcelInfo.classText || "--");
      setText("sumAddress", lastParcelInfo.addressText || "--");
      setText("sumCouncil", lastParcelInfo.councilText || "Logan City Council");
    }

    function outlineSelection(geom){
      selLayer.removeAll();
      if(!geom) return;
      selLayer.add(new Graphic({geometry:geom,symbol:{type:"simple-fill",color:[0,0,0,0],outline:{color:"#a70b13",width:2}}}));
    }
    function parcelInfoFromFeature(feat){
      const attrs= (feat && feat.attributes) || {};
      const meta=parseParcelMeta(attrs);
      const lotplan= meta.lotplan || ((meta.lot||meta.plan)?[meta.lot,meta.plan].filter(function(x){return !!x;}).join("/"):"--");
      const area= valOr(getLotAreaSqm(attrs), valOr(geomAreaSqmSafe(feat.geometry), null));
      const cls=(area!=null && area<450)?"Small lot":"Standard lot";
      var address=parseAddress(attrs) || "--";
      if(address && address!=="--") address = ensureSuburbInAddress(address, attrs);
      const council=parseCouncil(attrs) || "Logan City Council";
      return {
        lotText: lotplan||"--",
        areaText: (area!=null) ? (Math.round(area).toLocaleString()+" "+M2) : ("-- "+M2),
        classText: cls,
        addressText: address,
        councilText: council
      };
    }
    function updateBadgesFromFeature(feat){
      const info=parcelInfoFromFeature(feat);
      lastParcelInfo={feature:feat,lotText:info.lotText,areaText:info.areaText,classText:info.classText,addressText:info.addressText,councilText:info.councilText};
      updateSummaryPanel();
    }

    const bufferedAOIFor=function(node,geom){
      try{
        const gt=String(node.geometryType||"").toLowerCase();
        if(gt==="point"||gt==="multipoint"||gt==="polyline") return geometryEngine.buffer(geom,TOUCH_BUFFER_M,"meters");
      }catch(e){}
      return geom;
    };
    async function countFeatures(node,geom){
      const g=bufferedAOIFor(node,geom);
      try{
        if(typeof node.queryFeatureCount==="function"){
          const c=await node.queryFeatureCount({geometry:g,spatialRelationship:"intersects"});
          return Number(c)||0;
        }
      }catch(e){}
      try{
        if(typeof node.queryFeatures==="function"){
          const q=await node.queryFeatures({geometry:g,spatialRelationship:"intersects",returnGeometry:false,outFields:["*"],num:1});
          return (q.features&&q.features.length)?1:0;
        }
      }catch(e){}
      return 0;
    }

    async function swatchHTML(symbol){
      try{
        const el=await symbolUtils.renderPreviewHTML(symbol,{size:[SWATCH_PX-2,SWATCH_PX-2]});
        if(el && el.tagName && el.tagName.toLowerCase()==="canvas"){ return '<span class="swbox"><img alt="" src="'+el.toDataURL("image/png")+'"></span>'; }
        try{ if(el){ el.setAttribute("width","100%"); el.setAttribute("height","100%"); } }catch(e){}
        return '<span class="swbox">'+(el?el.outerHTML:"")+'</span>';
      }catch(e){ return '<span class="swbox" style="background:#cfcfcf"></span>'; }
    }
    const guessLabelFromAttrs = function(attrs){
      if (!attrs) return null;
      const patt = [
        /zone.*(name|type|desc|label|category|code)?/i,
        /(planning|scheme).*zone/i,
        /(zone|category|type|class|desc|label)/i
      ];
      for (var i=0;i<patt.length;i++) {
        var r = patt[i];
        var k = Object.keys(attrs).find(function(x){ return r.test(x); });
        if (k) {
          var v = String(valOr(attrs[k],"")).trim();
          if (v) return v;
        }
      }
      return null;
    };
    function getUVInfo(renderer,attrs){
      if(!renderer||!attrs) return null;
      const fields=[renderer.field,renderer.field2,renderer.field3].filter(function(x){return !!x;});
      const delim=(renderer.fieldDelimiter!=null)?renderer.fieldDelimiter:", ";
      if(!fields.length) return null;
      const parts=fields.map(function(f){ return attrs[f]; });
      const key=parts.join(delim);
      const infos=renderer.uniqueValueInfos||[];
      let info=infos.find(function(u){ return String(u.value)===String(key); });
      if(!info) info=infos.find(function(u){ return Array.isArray(u.values)&&u.values.some(function(v){ return String(v)===String(key); }); });
      if(!info && fields.length===1){
        info=infos.find(function(u){ return String(u.value)===String(attrs[fields[0]]); }) ||
             infos.find(function(u){ return Array.isArray(u.values)&&u.values.some(function(v){ return String(v)===String(attrs[fields[0]]); }); });
      }
      return info||null;
    }
    const ZONE_KEYS=["ZONE_CODE","ZONE","ZONE_NAME","ZONING","ZONE_LABEL","ZONE_DESC","ZONE_TYPE","ZONE_CATEGORY","PLANNING_ZONE"];
    function pickZoneLabel(attrs){
  if(!attrs) return null;
  const code=String(valOr(attrs.ZONE_CODE, attrs.ZONE) || "").trim();
  const name=String(valOr(attrs.ZONE_NAME, attrs.ZONING) || "").trim();
  if(code && name) return code + " - " + name;
  for(var i=0;i<ZONE_KEYS.length;i++){
    var k=ZONE_KEYS[i], v=attrs[k];
    if(v!=null && String(v).trim()) return String(v).trim();
  }
  return null;
}
    async function legendFromRendererUsingFeatures(layerNode,lotGeom){
      const gt=String(layerNode.geometryType||"").toLowerCase();
      const isZone=isZoning(layerNode.title||"",nodePath(layerNode));
      const g=(gt==="point"||gt==="multipoint"||gt==="polyline") ? geometryEngine.buffer(lotGeom,TOUCH_BUFFER_M,"meters") : lotGeom;

      let feats=[];
      try{
        const q=await layerNode.queryFeatures({geometry:g,spatialRelationship:"intersects",returnGeometry:true,outFields:["*"],maxRecordCountFactor:6});
        feats=q.features||[];
      }catch(e){}
      if(!feats.length) return {items:[]};

      const itemMap=new Map();
      for(var i=0;i<feats.length;i++){
        const f=feats[i];
        const gph=new Graphic({geometry:f.geometry,attributes:f.attributes,layer:layerNode});
        let sym=null;
        try{ sym=await symbolUtils.getDisplayedSymbol(gph,view); }catch(e){}
        if(!sym){
          const r=layerNode.renderer; sym = (r && (r.symbol || r.defaultSymbol)) || f.symbol || null;
        }
        if(!sym) continue;

        let label=isZone?pickZoneLabel(f.attributes):null;
        if(!label){
          const r2=layerNode.renderer;
          if(r2 && r2.type==="unique-value"){
            const info=getUVInfo(r2,f.attributes);
            if(info) label= (info.label != null) ? info.label : String(valOr(info.value, (info.values||[]).join(", ")));
          }else if(r2 && r2.type==="class-breaks" && r2.field){
            const v=Number((f.attributes&&f.attributes[r2.field]));
            if(!Number.isNaN(v)){
              const cbi=(r2.classBreakInfos||[]).find(function(b){
                const min=(b.minValue==null?-Infinity:b.minValue), max=(b.maxValue==null?Infinity:b.maxValue);
                return v>=min && v<=max;
              });
              label = (cbi && (cbi.label!=null ? cbi.label : (String(valOr(cbi.minValue,"")) + " to " + String(valOr(cbi.maxValue,""))))) || label;
            }
          }
          if(!label) label=(r2 && r2.label) || layerNode.title || guessLabelFromAttrs(f.attributes) || "Class";
        }
        const sw=await swatchHTML(sym);
        if(!itemMap.has(label)) itemMap.set(label,{label:label,swatchHTML:sw});
      }
      return {items:Array.from(itemMap.values())};
    }

    const HARDWIRED = {
      bushfire: [
        /bush\s*fire/i, /bushfire/i, /bush-?fire/i, /wild\s*fire/i, /bpa\b/i,
        /bushfire\s*prone/i, /bushfire\s*hazard/i, /qfes/i
      ],
      noise: [
        /transport\s*noise\s*corridor/i, /tnc\b/i, /state.*road.*noise/i,
        /road.*traffic.*noise/i, /tmr.*noise/i, /acoustic.*corridor/i
      ]
    };
    function strHay(node){ return (String(node.title||"")+" "+nodePath(node)+" "+(node.url||"")).toLowerCase(); }

    function leafDisplayNodes(root){
      const out=[];
      const visit=function(n){
        const kids=kidsOf(n);
        if(kids.length){ for(var i=0;i<kids.length;i++){ visit(kids[i]); } }
        else{ if("visible" in n) out.push(n); }
      };
      visit(root);
      return out;
    }

    function collectLeafDisplayNodesByPredicate(pred, opts){
      opts = opts || {};
      const includeDNT = !!opts.includeDNT;
      const out=[], seen=new Set();
      const pushUnique=function(node){
        if(!node || !("visible" in node)) return;
        const key=nodePath(node)||node.id||node.title||"node";
        if(seen.has(key)) return;
        seen.add(key);
        out.push(node);
      };
      walkAny(view.map,function(n,underDNT){
        if(!includeDNT && underDNT) return;
        const t=n.title||"", p=nodePath(n), id=n.id||"", tg=(n.portalItem && n.portalItem.tags)||[];
        if(!pred(n,t,p,id,tg)) return;
        const kids=kidsOf(n);
        if(kids.length){ leafDisplayNodes(n).forEach(pushUnique); }
        else{ pushUnique(n); }
      });
      return out;
    }

    function collectAllBushfireDisplayNodes(){
      return collectLeafDisplayNodesByPredicate(function(n,t,p,id,tg){
        const hay=strHay(n);
        return HARDWIRED.bushfire.some(function(rx){return rx.test(hay);}) || isBushfire(t,p);
      },{includeDNT:true});
    }
    function collectAllNoiseDisplayNodes(){
      return collectLeafDisplayNodesByPredicate(function(n,t,p,id,tg){
        const hay=strHay(n);
        return HARDWIRED.noise.some(function(rx){return rx.test(hay);}) || isNoise(t,p);
      },{includeDNT:true});
    }

    const ancestors=function(node){ const out=[]; var p=node?node.parent:null; while(p){ out.push(p); p=p.parent; } return out; };
    const owningLayer=function(node){ var c=node; while(c && c.type==="sublayer") c=c.parent; return (c && c.type!=="sublayer") ? c : null; };
    async function awaitRenderFor(nodes){
      const layers=Array.from(new Set(nodes.map(function(n){return owningLayer(n);}).filter(function(x){return !!x;})));
      const views=[];
      for(var i=0;i<layers.length;i++){ try{ views.push(await view.whenLayerView(layers[i])); }catch(e){} }
      if(views.length){ try{ await reactiveUtils.whenOnce(function(){ return views.every(function(v){ return v.updating===false; }); }); }catch(e){} }
      await waitViewIdle(240);
    }
    async function sumCounts(nodes,geom){ let t=0; for(var i=0;i<nodes.length;i++){ t+=await countFeatures(nodes[i],geom); } return t; }

    function saveVisibility(root){
      const map=new Map();
      walkAny(root,function(n){
        if("visible" in n){
          map.set(nodePath(n),{vis:!!n.visible,op:n.opacity,min:n.minScale,max:n.maxScale,blend:n.blendMode});
        }
      });
      return map;
    }
    function restoreVisibility(root,snap){
      walkAny(root,function(n){
        if("visible" in n){
          const k=nodePath(n);
          if(snap.has(k)){
            const s=snap.get(k);
            try{ n.visible=s.vis; }catch(e){}
            if("opacity" in n && s.op!==undefined){ try{ n.opacity=s.op; }catch(e){} }
            if("blendMode" in n && s.blend!==undefined){ try{ n.blendMode=s.blend; }catch(e){} }
            try{ n.minScale=s.min; n.maxScale=s.max; }catch(e){}
          }
        }
      });
    }

    function underDNTChain(node){
      let cur=node;
      while(cur){
        const t=cur.title||"", id=cur.id||"", tg=(cur.portalItem&&cur.portalItem.tags)||[];
        if(isDNT(t,id,tg)) return true;
        cur=cur.parent;
      }
      return false;
    }

    async function screenshotFor(nodes,title,lotGeom,legendOnLot,opts){
      legendOnLot = !!legendOnLot;
      opts = opts || {};
      const forceAllVisible = !!opts.forceAllVisible;

      if(!nodes || !nodes.length || !lotGeom) return null;

      const present=forceAllVisible ? nodes.slice() : [];
      if(!forceAllVisible){
        for(var i=0;i<nodes.length;i++){ if(await countFeatures(nodes[i],lotGeom)>0) present.push(nodes[i]); }
      }
      if(!present.length && !forceAllVisible) return null;

      const visSnap=saveVisibility(view.map), scaleSnap=new Map(), opSnap=new Map(), blendSnap=new Map();

      try{
        return await withViewOnGeom(lotGeom, async function(){
          walkAny(view.map,function(n){
            if(!("visible"in n)) return;
            if(underDNTChain(n)) return;
            try{ n.visible=false; }catch(e){}
          });
          try{ selLayer.visible=true; }catch(e){}

          const targets = present.length ? present : nodes;

          for(var i=0;i<targets.length;i++){
            var n=targets[i];
            var chain=[n].concat(ancestors(n));
            for(var j=0;j<chain.length;j++){
              var a=chain[j];
              if(!("visible"in a)) continue;
              try{ a.visible=true; }catch(e){}
              if("minScale"in a || "maxScale"in a){
                if(!scaleSnap.has(a)) scaleSnap.set(a,{min:a.minScale,max:a.maxScale});
                try{ a.minScale=0; a.maxScale=0; }catch(e){}
              }
            }
            if("blendMode"in n){ if(!blendSnap.has(n)) blendSnap.set(n,n.blendMode); }
            if("opacity"in n){ if(!opSnap.has(n))    opSnap.set(n,n.opacity); }
          }
          await awaitRenderFor(targets);

          const shot=await view.takeScreenshot({format:"png",quality:95,width:SHOT_SIZE.width,height:SHOT_SIZE.height});

          var legendGeom=lotGeom;
          if(!legendOnLot){
            try{
              const onScr=geometryEngine.intersect(lotGeom,view.extent);
              if(onScr) legendGeom=onScr;
            }catch(e){}
          }

          const legendParts=[];
          for(var k=0;k<targets.length;k++){
            var ln=targets[k];
            if(underDNTChain(ln)) continue;
            if(typeof ln.queryFeatures!=="function" && typeof ln.queryFeatureCount!=="function") continue;
            const res=await legendFromRendererUsingFeatures(ln,legendGeom);
            const items=res.items||[];
            if(items.length){
              const inner=items.map(function(i){ return '<div class="row">'+i.swatchHTML+i.label.replace(/&/g,"&amp;")+'</div>'; }).join("");
              legendParts.push('<div style="margin-bottom:6px"><b>'+ String(ln.title||"Layer").replace(/&/g,"&amp;") +'</b><div class="leg" style="margin-top:4px">'+inner+'</div></div>');
            }
          }

          const count=await sumCounts(nodes,lotGeom);
          return {title:title,id:"rpt-"+slug(title),dataUrl:shot.dataUrl,legendHTML:legendParts.join(""),count:count};
        });
      } finally {
        for(const [n,op] of opSnap){ try{n.opacity=op;}catch(e){} }
        for(const [n,bl] of blendSnap){ try{n.blendMode=bl;}catch(e){} }
        for(const [n,sc] of scaleSnap){ try{n.minScale=sc.min;n.maxScale=sc.max;}catch(e){} }
        restoreVisibility(view.map,visSnap);
      }
    }

    function setRpt(msg,pct,doneStepId){
      const bar=$("rptBar"), m=$("rptMsg");
      if(m && msg!=null) m.textContent=msg;
      if(bar && pct!=null) bar.style.width=Math.max(0,Math.min(100,pct))+"%";
      if(doneStepId){ const step=$(doneStepId); if(step) step.classList.add("rptDone"); }
    }

    async function addMandatorySection(shots, title, collectorFn, geom, baseShot, emptyNote){
      try{
        const nodes = collectorFn();
        if(nodes.length){
          const s = await screenshotFor(nodes, title, geom, false, {forceAllVisible:true});
          if(!s){ shots.push({title:title,id:"rpt-"+slug(title),dataUrl:baseShot.dataUrl,legendHTML:"",count:0,note:emptyNote}); }
          else { if((s.count||0)===0) s.note=emptyNote; shots.push(s); }
        }else{
          shots.push({title:title,id:"rpt-"+slug(title),dataUrl:baseShot.dataUrl,legendHTML:"",count:0,note:emptyNote});
        }
      }catch(err){
        console.warn("Mandatory section failed:", title, err);
        shots.push({title:title,id:"rpt-"+slug(title),dataUrl:baseShot.dataUrl,legendHTML:"",count:0,note:emptyNote+" (layer unavailable)"});
      }
    }

    function dedupeShotsByTitle(shots, title){
      const target=(title||"").trim().toLowerCase();
      if(!target) return;
      let seen=false;
      for(let i=shots.length-1;i>=0;i--){
        const cur=(shots[i]?.title||"").trim().toLowerCase();
        if(cur===target){
          if(seen){ shots.splice(i,1); }
          else{ seen=true; }
        }
      }
    }

    /* ---------------- Build report ---------------- */
    $("btnPrintReport").addEventListener("click", async function(){
      $("rptOverlay").style.display="grid";
      try{ await buildAndOpenReport(); } finally { $("rptOverlay").style.display="none"; }
    });

    async function buildAndOpenReport(){
      try{
        showLoading(true);
        setRpt("Locating parcel...", 12);
        var geom=null, lotText="--", areaText="-- "+M2, classText="--", addressText="--", councilText="Logan City Council";
        if(lastParcelInfo.feature){
          geom=lastParcelInfo.feature.geometry; lotText=lastParcelInfo.lotText; areaText=lastParcelInfo.areaText; classText=lastParcelInfo.classText; addressText=lastParcelInfo.addressText; councilText=lastParcelInfo.councilText;
        }else{
          const probe=await findParcelAtPoint(view.center);
          if(probe){
            const info=parcelInfoFromFeature(probe); geom=probe.geometry;
            lotText=info.lotText; areaText=info.areaText; classText=info.classText; addressText=info.addressText; councilText=info.councilText;
            lastParcelInfo={feature:probe,lotText:lotText,areaText:areaText,classText:classText,addressText:addressText,councilText:councilText};
          }
        }
        setRpt("Parcel located", 18, "rptS1");

        if(geom){
          setRpt("Resolving address...", 25);
          try{ addressText=await resolveBestAddress(geom,lastParcelInfo.feature); }catch(e){}
          setRpt("Address resolved", 35, "rptS2");
          lastParcelInfo.addressText = addressText || lastParcelInfo.addressText;
        }

        setRpt("Rendering base map...", 42);
        const baseShot = geom
          ? await withViewOnGeom(geom, async function(){ try{selLayer.visible=true;}catch(e){}; await waitViewIdle(200); return await view.takeScreenshot({format:"png",quality:95,width:SHOT_SIZE.width,height:SHOT_SIZE.height}); })
          : await view.takeScreenshot({format:"png",quality:95,width:SHOT_SIZE.width,height:SHOT_SIZE.height});

        setRpt("Collecting overlays...", 55);
        var cats;
        if(geom){
          cats = await (async function(){
            const out={zoning:[],utilities:[],acid:[],transport:[],air:[],noise:[],bushfire:[],others:[]};
            const arr=[];
            walkAny(view.map,function(n,underDNT){
              if(n && (n.type==="feature"||n.type==="sublayer") && (typeof n.queryFeatures==="function" || typeof n.queryFeatureCount==="function") && !underDNT) arr.push(n);
            });
            for(var i=0;i<arr.length;i++){
              const n=arr[i];
              try{
                await n.load();
                const cnt=await countFeatures(n,geom); if(!cnt) continue;
                const t=n.title||"", p=nodePath(n);
                if(isZoning(t,p)) out.zoning.push(n);
                else if(isUtility(t,n.id,(n.portalItem && n.portalItem.tags)||[]) || isWaterOrSewer(p)) out.utilities.push(n);
                else if(isAcid(t,p)) out.acid.push(n);
                else if(isNoise(t,p)) out.noise.push(n);
                else if(isTransport(t,p)) out.transport.push(n);
                else if(isAir(t,p)) out.air.push(n);
                else if(isBushfire(t,p)) out.bushfire.push(n);
                else out.others.push(n);
              }catch(e){}
            }
            return out;
          })();
        }else{
          cats={zoning:[],utilities:[],acid:[],transport:[],air:[],noise:[],others:[]};
        }

        const shots=[];
        const tasks=[
          ["Zoning", async function(){ if(cats.zoning.length){ const s=await screenshotFor(cats.zoning,"Zoning",geom,true); if(s) shots.push(s); } }],
          ["Bushfire", async function(){ await addMandatorySection(shots,"Bushfire",collectAllBushfireDisplayNodes,geom,baseShot,"No bushfire Lv"); }],
          ["Utilities", async function(){ const all=collectLeafDisplayNodesByPredicate(function(n,t,p,id,tg){ return isUtility(t,id,tg)||isWaterOrSewer(p); },{includeDNT:true}); if(all.length){ const s=await screenshotFor(all,"Utilities",geom,false,{forceAllVisible:true}); if(s) shots.push(s); } } ],
          ["Acid overlays", async function(){ if(cats.acid.length){ const s=await screenshotFor(cats.acid,"Acid overlays",geom); if(s) shots.push(s); } }],
          ["Transport", async function(){ if(cats.transport.length){ const s=await screenshotFor(cats.transport,"Transport",geom); if(s) shots.push(s); } }],
          ["Air quality", async function(){ if(cats.air.length){ const s=await screenshotFor(cats.air,"Air quality",geom); if(s) shots.push(s); } }],
          ["Transport Noise Corridor", async function(){ await addMandatorySection(shots,"Transport Noise Corridor",collectAllNoiseDisplayNodes,geom,baseShot,"No noise Lv"); }],
          ["Other overlays", async function(){ for (var i=0;i<cats.others.length;i++) { const n=cats.others[i]; const t=n.title||"", p=nodePath(n); if (isBushfire(t,p) || isNoise(t,p)) continue; const s=await screenshotFor([n], n.title || "Overlay", geom); if (s) shots.push(s); } }]
        ];
        for(var ti=0;ti<tasks.length;ti++){
          const name=tasks[ti][0], fn=tasks[ti][1];
          setRpt("Rendering " + name + "...", 55 + Math.round(((ti+1)/tasks.length)*30));
          await fn();
        }
        dedupeShotsByTitle(shots,"Transport Noise Corridor");
        setRpt("Overlays rendered", 87, "rptS3");

        setRpt("Composing document...", 93);
        const now=new Date();
        const fmt=function(d){ return d.toLocaleString(undefined,{year:'numeric',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'}); };
        const esc=htmlEsc;
        const logoSrc="./images/Flavour icon.png";

        // ===== Dynamic titles for print/download =====
        const toFileSafe = function(s){ return String(s).replace(/[<>:"/\\|?*\x00-\x1F]/g, "").replace(/\s+/g, " ").trim(); };
        const baseName = (lastParcelInfo.addressText && lastParcelInfo.addressText !== "--")
          ? lastParcelInfo.addressText
          : ((lastParcelInfo.lotText && lastParcelInfo.lotText !== "--") ? ("Lot " + lastParcelInfo.lotText) : "Property");
        const reportDisplayTitle = baseName + " - Property Report";
        const reportFileTitle = toFileSafe(reportDisplayTitle);

        const html=[];
        html.push("<!doctype html><meta charset='utf-8'><title>", esc(reportFileTitle), "</title>");
        html.push("<style>",
          "body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:24px;color:#222;background:#f6f7f9}",
          ".card{border:1px solid #e1e3e6;border-radius:12px;padding:14px;margin:10px 0;background:#fff;box-shadow:0 2px 10px rgba(16,21,28,.05)}",
          ".brandbar{display:flex;align-items:center;gap:12px;padding:14px 16px;margin:-14px -14px 14px -14px;color:#fff;background:linear-gradient(90deg,#a70b13,#7f0e15);border-radius:12px 12px 0 0}",
          ".brandbar img{width:28px;height:28px;border:1px solid #ddd;background:#fff;border-radius:6px}",
          ".brandbar h1{margin:0;font-size:18px;font-weight:800;letter-spacing:.2px}",
          ".brandbar .muted{margin-left:auto;opacity:.95;font-weight:600}",
          ".rpt-grid{display:grid;grid-template-columns:1fr 1.25fr;gap:18px}",
          ".propmap{grid-column:1 / -1}",
          ".propmap-grid{display:grid;grid-template-columns:1fr 1.6fr;gap:16px;align-items:start}",
          ".badge-pill{display:inline-block;border:1px solid #dadde2;border-radius:999px;padding:4px 10px;margin:4px 6px 0 0;background:#fafbfc}",
          ".kv{margin-top:8px;font-size:14px;color:#333}.kv div{margin:4px 0}",
          "img.map{max-width:100%;border:1px solid #e1e3e6;border-radius:10px}",
          ".section-title{margin:0 0 10px;font-size:18px}",
          ".overlay-header{display:flex;align-items:center;justify-content:space-between;gap:8px}",
          ".backbtn{display:inline-block;border:1px solid #d7d7d7;border-radius:999px;padding:6px 10px;font-size:12px;color:#333;text-decoration:none;background:#f7f7f7}.backbtn:hover{background:#eee}",
          ".sumlist{margin:6px 0 0 18px;padding:0}.sumlist li{margin:8px 0 12px}",
          ".note{margin-top:8px;font-size:13px;color:#7a0f16;font-weight:700}",
          ".leg{font-size:13px;line-height:1.35;margin-top:8px}.leg .row{display:flex;align-items:center;gap:8px;margin:2px 0}",
          ".leg .swbox{display:inline-flex;align-items:center;justify-content:center;width:16px;height:14px;padding:1px;border:1px solid #999;border-radius:3px;overflow:hidden;background:#fff}",
          ".leg .swbox img,.leg .swbox svg,.leg .swbox canvas{width:100%;height:100%;display:block;object-fit:contain}",
          ".rpt-footer{margin-top:14px;padding-top:8px;border-top:1px dashed #ddd;font-size:12px;color:#555}",
          "@media print{*{-webkit-print-color-adjust:exact!important;print-color-adjust:exact!important}.card{page-break-inside:avoid}}",
          "</style>");
        html.push("<body>");
        html.push(
          "<div class='card brandbar'>",
            "<img src='",logoSrc,"' alt='Logo' style='width:28px;height:28px;vertical-align:-3px;border-radius:3px;border:1px solid #ddd;background:#fff;margin-right:6px'/>",
            "<h1>", esc((lastParcelInfo.addressText && lastParcelInfo.addressText!=="--") ? lastParcelInfo.addressText : "Logan Interactive Mapping - Property Report"), "</h1>",
            "<div class='muted'>",fmt(now),"</div>",
          "</div>"
        );

        html.push("<div class='rpt-grid'>");
          html.push("<div class='card propmap'>",
                      "<div class='propmap-grid'>",
                        "<div>",
                          "<h2 class='section-title'>Property</h2>",
                          "<div class='badge-pill'>Lot: ",esc(lastParcelInfo.lotText),"</div>",
                          "<div class='badge-pill'>Area: ",esc(lastParcelInfo.areaText),"</div>",
                          "<div class='badge-pill'>Class: ",esc(lastParcelInfo.classText),"</div>",
                          "<div class='kv'>",
                            "<div><b>Address:</b> ",esc(lastParcelInfo.addressText),"</div>",
                            "<div><b>Council:</b> ",esc(lastParcelInfo.councilText),"</div>",
                          "</div>",
                          "<div id='summary' style='margin-top:14px'>",
                            "<h2 class='section-title' style='margin-top:0'>Summary</h2>");
                            if(shots.length){
                              html.push("<ul class='sumlist'>");
                              for(var si=0;si<shots.length;si++){
                                var ss=shots[si];
                                html.push("<li><a class='sum-link' style='color:#7a0f16;font-weight:700;text-decoration:none' href='#",ss.id,"'>",esc(ss.title),"</a></li>");
                              }
                              html.push("</ul>");
                            }else{
                              html.push("<i>No overlays intersect this parcel (excluding DNT groups).</i>");
                            }
                          html.push("</div>",
                        "</div>",
                        "<div><h2 class='section-title'>Map</h2><img class='map' src='",baseShot.dataUrl,"' alt='Map'></div>",
                      "</div>",
                      "<div class='rpt-footer'>Generated by CornerstonePlus. Confirm against the current planning scheme and authoritative datasets before relying on this report.</div>",
                    "</div>");
        html.push("</div>");

        for(var si2=0;si2<shots.length;si2++){
          var s=shots[si2];
          html.push("<div class='card' id='",s.id,"'>",
            "<div class='overlay-header'><h2 class='section-title' style='margin:0'>",esc(s.title),"</h2><a class='backbtn' href='#summary'>Back to Summary</a></div>",
            "<img class='map' src='",s.dataUrl,"' alt='",esc(s.title),"'>",
            (s.note ? "<div class='note'>"+esc(s.note)+"</div>" : ""),
            "<div class='leg'>", (s.legendHTML || ""), "</div>",
          "</div>");
        }

        html.push("<div class='card rpt-footer'><img src='"+logoSrc+"' alt='Logo' style='width:18px;height:18px;vertical-align:-3px;border-radius:3px;border:1px solid #ddd;background:#fff;margin-right:6px'/> (c) Logan City Council - CornerstonePlus. Indicative only.</div>");
        html.push("</body>");

        const w=window.open("about:blank","_blank");
        if(w){
          w.document.open();
          w.document.write(html.join(""));
          w.document.close();
          try { w.document.title = reportFileTitle; } catch(e){}
          setTimeout(function(){ try{ w.focus(); w.print(); }catch(e){} },350);
        }
        setRpt("Done", 100, "rptS4");
      }catch(e){ console.error(e); alert("Could not create report."); }
      finally{ showLoading(false); }
    }

    /* ---------------- Tabs & Home ---------------- */
    [["summary"],["setbacks"],["proposal"],["yield"]].forEach(function(pair){
      const name=pair[0];
      const t=$("tab-"+name), p=$("panel-"+name);
      if(!t||!p) return;
      t.addEventListener("click",function(){
        Array.prototype.forEach.call(document.querySelectorAll(".tab"),function(el){ el.setAttribute("aria-selected","false"); });
        Array.prototype.forEach.call(document.querySelectorAll(".panel"),function(el){ el.classList.remove("active"); });
        t.setAttribute("aria-selected","true"); p.classList.add("active");
      });
    });
    $("btnHome").addEventListener("click",function(){
      fetch("Index.html",{method:"HEAD"}).then(function(){ window.location.href="Index.html"; })
        .catch(function(){
          if (history.length > 1) { history.back(); } else { window.location.href = "./"; }
        });
    });

    /* ---------------- POD Upload ---------------- */
    (function initPodUpload(){
      const form = $("podForm");
      const input = $("podFile");
      const statusEl = $("podStatus");
      const list = $("podResultList");
      const wrap = $("podResultWrap");
      const submitBtn = $("podSubmitBtn");
      if(!form || !input || !statusEl) return;

      const setStatus = function(msg, isError){
        statusEl.textContent = msg;
        statusEl.classList.toggle("error", !!isError);
      };
      const setBusy = function(busy){
        if(submitBtn){
          submitBtn.disabled = busy;
          submitBtn.textContent = busy ? "Uploading..." : "Upload & Import";
        }
        if(input){
          input.disabled = busy;
        }
      };
      const renderResults = function(items){
        items = items || [];
        if(!wrap || !list) return;
        if(!items.length){
          wrap.hidden = true;
          list.innerHTML = "";
          return;
        }
        wrap.hidden = false;
        list.innerHTML = items.map(function(sub){
          const lotRaw = sub.lot || "";
          const planRaw = sub.plan || "";
          const lot = htmlEsc(lotRaw || "?");
          const plan = htmlEsc(planRaw || "Unknown plan");
          const area = sub.areaSqm ? (sub.areaSqm.toLocaleString()+" sqm") : "Area N/A";
          const btn = (sub.lot && sub.plan)
            ? "<button class=\"pod-zoom-btn\" data-lot=\""+attrEsc(lotRaw)+"\" data-plan=\""+attrEsc(planRaw)+"\">Use</button>"
            : "";
          return "<li><div class=\"pod-result-row\">"+btn+"<div>Lot "+lot+" on "+plan+" ("+area+")</div></div></li>";
        }).join("");
      };
      list && list.addEventListener("click", async function(evt){
        const btn = evt.target.closest(".pod-zoom-btn");
        if(!btn) return;
        evt.preventDefault();
        let lot = btn.getAttribute("data-lot");
        let plan = btn.getAttribute("data-plan");
        if(!lot || !plan){
          const txt = (btn.closest(".pod-result-row") || {}).innerText || "";
          const m = txt.match(/Lot\\s+(\\S+)\\s+on\\s+(\\S+)/i);
          if(m){ lot = m[1]; plan = m[2]; }
        }
        if(!lot || !plan){
          setStatus("Missing lot/plan on selection.", true);
          return;
        }
        setBusy(true);
        setStatus("Zooming to Lot "+lot+" on "+plan+"...");
        const ok = await focusOnLotPlan(lot, plan);
        setBusy(false);
        setStatus(ok ? ("Focused on Lot "+lot+" on "+plan+".") : ("Could not locate Lot "+lot+" on "+plan+" in the available parcel datasets."), !ok);
      });

      input.addEventListener("change",function(){
        const file = input.files && input.files[0];
        const nameEl = $("podFileName");
        if(file){
          if(nameEl) nameEl.textContent = file.name;
          setStatus("Ready to import "+file.name);
        }else{
          if(nameEl) nameEl.textContent = "No file chosen";
          setStatus("Select a POD PDF to begin.");
          renderResults([]);
        }
      });

      form.addEventListener("submit", async function(evt){
        evt.preventDefault();
        if(!input.files || !input.files.length){
          setStatus("Choose a POD PDF first.", true);
          return;
        }
        const file = input.files[0];

        setBusy(true);
        setStatus("Parsing PDF locally...");
        renderResults([]);

        try{
          const text = await extractPdfText(file);
          if(!text || !text.trim()){
            throw new Error("PDF did not contain readable text.");
          }
          const subdivisions = parseSubdivisionsFromText(text);
          renderResults(subdivisions);

          const count = subdivisions.length;
          let msg = count ? ("Parsed "+count+" subdivision"+(count===1? "":"s")+" locally.") : "No subdivisions detected.";
          let statusError = false;
          const focusTarget = subdivisions.find(function(sub){ return sub.lot && sub.plan; });
          if(count === 1 && focusTarget){
            const zoomed = await focusOnLotPlan(focusTarget.lot, focusTarget.plan);
            if(zoomed){
              msg += " Zoomed to Lot "+focusTarget.lot+" on "+focusTarget.plan+".";
            }else{
              msg += " Could not locate Lot "+focusTarget.lot+" on "+focusTarget.plan+" in the available parcel datasets.";
              statusError = true;
            }
          }else if(count > 1){
            msg += " Choose a lot below to zoom.";
          }
          msg += " Upload to ArcGIS coming soon.";
          setStatus(msg, statusError);
        }catch(err){
          console.error(err);
          setStatus(err.message || "Local parsing failed", true);
        }finally{
          setBusy(false);
        }
      });

      const dropZone = $("podDropZone");
      const setFile = function(file){
        if(!file) return;
        const dt = new DataTransfer();
        dt.items.add(file);
        input.files = dt.files;
        const nameEl = $("podFileName");
        if(nameEl) nameEl.textContent = file.name;
        setStatus("Ready to import "+file.name);
      };
      const prevent = function(e){ e.preventDefault(); e.stopPropagation(); };
      ["dragenter","dragover","dragleave","drop"].forEach(function(ev){
        if(dropZone) dropZone.addEventListener(ev, prevent);
      });
      if(dropZone){
        dropZone.addEventListener("dragenter", function(){ dropZone.classList.add("dragover"); });
        dropZone.addEventListener("dragleave", function(){ dropZone.classList.remove("dragover"); });
        dropZone.addEventListener("dragend", function(){ dropZone.classList.remove("dragover"); });
        dropZone.addEventListener("drop", function(ev){
          dropZone.classList.remove("dragover");
          const file = ev.dataTransfer && ev.dataTransfer.files && ev.dataTransfer.files[0];
          if(file && file.type==="application/pdf"){
            setFile(file);
          }else{
            setStatus("Drop a PDF file.", true);
          }
        });
      }
    })();

    /* ============================================================
       === Lot/Plan Search source (QLD) ============================
       ============================================================ */

    function normalizePlanText(p){ return String(p||"").toUpperCase().replace(/\s+/g,""); }
    function parseLotPlan(text){
      if(!text) return null;
      var s=String(text).toUpperCase();
      s=s.replace(/[,]+/g," ").replace(/\bon\b/ig," ").replace(/\blot\b/ig," ").replace(/\s+/g," ").trim();
      var m = s.match(/^\s*(\d+)\s*\/\s*([A-Z]{1,4}\s*\d{1,8})\s*$/);
      if(m) return {lot:m[1], plan:normalizePlanText(m[2])};
      m = s.match(/^\s*(\d+)\s+([A-Z]{1,4}\s*\d{1,8})\s*$/);
      if(m) return {lot:m[1], plan:normalizePlanText(m[2])};
      m = s.match(/^\s*([A-Z]{1,4}\s* \d{1,8})\s+(\d+)\s*$/);
      if(m) return {lot:m[2], plan:normalizePlanText(m[1])};
      return null;
    }

    let _parcelLayerCache=null;
    async function getParcelLayers(){
      if(_parcelLayerCache) return _parcelLayerCache;
      const candidates=flattenFeatureNodes();
      const polys=[];
      for(var i=0;i<candidates.length;i++){
        var node=candidates[i];
        try{
          await node.load();
          if(node.geometryType==="polygon" && (looksLikeParcelLayer(node) || hasParcelFields(node))){
            polys.push(node);
          }
        }catch(e){}
      }
      _parcelLayerCache=polys;
      return polys;
    }

    function escSQL(s){ return String(s).replace(/'/g,"''"); }
    function isIntegerField(f){ const t=String(f.type||"").toLowerCase(); return t.indexOf("integer")!==-1; }
    function isTextField(f){ const t=String(f.type||"").toLowerCase(); return t.indexOf("string")!==-1; }

    function buildLotPlanWhere(layer, lot, plan){
      const flds = Array.isArray(layer.fields)?layer.fields:[];
      const lotFields = flds.filter(function(f){
        const nm = String(f.name||"").toUpperCase();
        if(/LOT_AREA/.test(nm)) return false;
        return /\b(LOT|LOTNO|LOT_NO|LOTNUMBER|LOT_NUM|LOTNUM)\b/.test(nm) || /^LOT$/.test(nm);
      });
      const planFields = flds.filter(function(f){
        const nm = String(f.name||"").toUpperCase();
        return /\b(PLAN|PLAN_NO|PLANNO|LOT_PLAN|LOTPLAN|LOT_PLAN_TXT|LOTPLAN_TXT)\b/.test(nm);
      });

      const lotClauses=[];
      const lotNum = Number(lot);
      for(var i=0;i<lotFields.length;i++){
        var f=lotFields[i];
        if(isIntegerField(f) && !Number.isNaN(lotNum)){
          lotClauses.push(f.name + "=" + lotNum);
        }else if(isTextField(f)){
          lotClauses.push("UPPER(" + f.name + ") LIKE '%" + escSQL(String(lot).toUpperCase()) + "%'");
        }
      }

      const planClauses=[];
      const planU = escSQL(plan.toUpperCase());
      const planCompact = escSQL(plan.toUpperCase().replace(/[^A-Z0-9]/g,""));
      const lotPlanFull = escSQL((String(lot)+"/"+plan).toUpperCase());
      const lotPlanCompact = escSQL((String(lot)+plan).toUpperCase().replace(/[^A-Z0-9]/g,""));
      for(var j=0;j<planFields.length;j++){
        var f2=planFields[j];
        if(isTextField(f2)){
          var fieldExpr = "UPPER(" + f2.name + ")";
          var scrubExpr = "REPLACE(REPLACE(REPLACE(" + fieldExpr + ", ' ', ''), '-', ''), '/', '')";
          planClauses.push(fieldExpr + " LIKE '%" + planU + "%'");
          planClauses.push(scrubExpr + " LIKE '%" + planCompact + "%'");
          if(/LOT[_ ]?PLAN|LOTPLAN|LOT_PLAN/i.test(f2.name)){
            planClauses.push(fieldExpr + " LIKE '%" + lotPlanFull + "%'");
            planClauses.push(scrubExpr + " LIKE '%" + lotPlanCompact + "%'");
          }
        }
      }

      const parts=[];
      if(lotClauses.length) parts.push("("+lotClauses.join(" OR ")+")");
      if(planClauses.length) parts.push("("+planClauses.join(" OR ")+")");
      if(!parts.length) return null;
      return parts.join(" AND ");
    }

    function buildFallbackLotPlanWhere(lot, plan){
      if(!lot || !plan) return null;
      const lotU = escSQL(String(lot).toUpperCase());
      const planU = escSQL(plan.toUpperCase());
      const planCompact = escSQL(plan.toUpperCase().replace(/[^A-Z0-9]/g,""));
      const lotPlanFull = escSQL((String(lot)+"/"+plan).toUpperCase());
      const lotPlanCompact = escSQL((String(lot)+plan).toUpperCase().replace(/[^A-Z0-9]/g,""));
      return [
        "(",
        "  UPPER(lot)='"+lotU+"'",
        "  OR UPPER(lotplan) LIKE '%"+lotPlanFull+"%'",
        "  OR REPLACE(REPLACE(REPLACE(UPPER(lotplan),' ',''),'-',''),'/','') LIKE '%"+lotPlanCompact+"%'",
        ") AND (",
        "  UPPER(plan) LIKE '%"+planU+"%'",
        "  OR REPLACE(REPLACE(REPLACE(UPPER(plan),' ',''),'-',''),'/','') LIKE '%"+planCompact+"%'",
        "  OR REPLACE(REPLACE(REPLACE(UPPER(lotplan),' ',''),'-',''),'/','') LIKE '%"+lotPlanCompact+"%'",
        ")"
      ].join("\\n");
    }

    async function queryLotPlanFallback(lot, plan){
      if(!LOTPLAN_FALLBACK_URLS.length) return [];
      const results=[];
      const compact = (""+lot+plan).toUpperCase().replace(/[^A-Z0-9]/g,"");
      for(const url of LOTPLAN_FALLBACK_URLS){
        const isLotplanOnly = /LandParcelPropertyFramework/gi.test(url);
        const where = isLotplanOnly
          ? "UPPER(lotplan)='"+compact+"'"
          : (buildFallbackLotPlanWhere(lot, plan) || "UPPER(lotplan)='"+compact+"'");
        try{
          const params = new URLSearchParams({
            f:"json",
            where:where,
            outFields:"*",
            returnGeometry:"true",
            outSR:String((view && view.spatialReference && view.spatialReference.wkid)||3857),
            maxRecordCountFactor:"5"
          });
          const res = await fetch(url+"/query",{
            method:"POST",
            headers:{"Content-Type":"application/x-www-form-urlencoded"},
            body:params
          });
          if(!res.ok) throw new Error("Fallback lot plan query failed: "+res.status);
          const json = await res.json();
          (json.features||[]).forEach(function(f){
            const g = (Graphic.fromJSON ? Graphic.fromJSON(f) : new Graphic({geometry:f.geometry,attributes:f.attributes}));
            if(!g.geometry && f.geometry) g.geometry = f.geometry;
            if(g.geometry && !g.geometry.spatialReference && view && view.spatialReference){
              g.geometry.spatialReference = view.spatialReference;
            }
            results.push({layer:{title:"Lot/Plan (Fallback)"}, feature:g});
          });
          if(results.length) break;
        }catch(e){
          console.warn("Lot/Plan fallback error:", e);
        }
      }
      return results;
    }

    async function queryLotPlanAcrossLayers(lot, plan){
      const layers = await getParcelLayers();
      const out=[];
      for(var i=0;i<layers.length;i++){
        const L=layers[i];
        try{
          const where = buildLotPlanWhere(L, lot, plan);
          if(!where) continue;
          const q = await L.queryFeatures({
            where: where,
            outFields:["*"],
            returnGeometry:true,
            maxRecordCountFactor:5
          });
          for(var j=0;j<(q.features||[]).length;j++){
            out.push({layer:L, feature:q.features[j]});
          }
        }catch(e){ /* per-layer errors ignored */ }
      }
      if(!out.length){
        const fallback = await queryLotPlanFallback(lot, plan);
        if(fallback && fallback.length) out.push.apply(out,fallback);
      }
      return out;
    }

    async function focusOnLotPlan(lot, plan){
      if(!lot || !plan) return false;
      try{
        await view.when();
        showLoading(true);
        console.log("[LotPlan] searching", lot, plan);
        const fb = await queryLotPlanFallback(lot, plan);
        if(fb && fb.length){
          await focusOnParcelFeature(fb[0].feature,{shouldZoom:true});
          return true;
        }
        const matches = await queryLotPlanAcrossLayers(lot, plan);
        if(matches && matches.length){
          await focusOnParcelFeature(matches[0].feature,{shouldZoom:true});
          return true;
        }
        console.warn("[LotPlan] no hits for", lot, plan);
        return false;
      }catch(err){
        console.warn("focusOnLotPlan error:", err);
        return false;
      }finally{
        showLoading(false);
      }
    }

    const lotPlanSource = {
      name: "Lot/Plan (QLD)",
      placeholder: "12/SP12345 or 'Lot 12 on SP12345'",
      getSuggestions: async function(params){
        const p = parseLotPlan(params.text);
        if(!p) return [];
        return [{ key: p.lot+"/"+p.plan, text: "Lot "+p.lot+" on "+p.plan, sourceIndex: 0 }];
      },
      getResults: async function(params){
        let txt = params.text || "";
        if(params.suggestResult && params.suggestResult.key) txt = params.suggestResult.key;
        const p = parseLotPlan(txt);
        if(!p) return [];
        const matches = await queryLotPlanAcrossLayers(p.lot, p.plan);
        return matches.map(function(m,i){
          var ext = (m.feature && m.feature.geometry && m.feature.geometry.extent) ? m.feature.geometry.extent : null;
          return { name: "Lot "+p.lot+" on "+p.plan+" - "+(m.layer.title||"Parcels"), feature: m.feature, extent: ext };
        });
      },
      zoomScale: 1000
    };

    search.sources.add(lotPlanSource);

    search.on("select-result", async function(e){
      try{
        const feat = e.result && e.result.feature;
        if(feat && feat.geometry){
          await focusOnParcelFeature(feat,{shouldZoom:true});
        }
      }catch(err){ console.warn("select-result handler:", err); }
    });

    async function hideUnusedOverlaysFor(geom){
      const nodes=[];
      walkAny(view.map,function(n){
        if(n && (n.type==="feature"||n.type==="sublayer") &&
           (typeof n.queryFeatures==="function" || typeof n.queryFeatureCount==="function")) nodes.push(n);
      });
      for(var i=0;i<nodes.length;i++){
        const n=nodes[i];
        const t=n.title||n.id||"", id=n.id||"", tg=(n.portalItem && n.portalItem.tags)||[];
        if(isDNT(t,id,tg)) continue;
        if(isUtility(t,id,tg)) continue;
        if(isWaterOrSewer(nodePath(n))) continue;
        try{ await n.load(); const cnt=await countFeatures(n,geom); if("listMode"in n) n.listMode=cnt>0?"show":"hide"; }catch(e){}
      }
      try{ layerList.refresh(); }catch(e){}
    }

    async function updateSideOverlaySummary(geom){
      const ul = $("sumOverlays");
      if (!ul) return;
      ul.innerHTML = "<li><i>Scanning...</i></li>";

      const items = [];
      const nodes = flattenFeatureNodes().filter(function(n){ return !underDNTChain(n); });

      for (var i=0;i<nodes.length;i++){
        const n = nodes[i];
        try{
          const t = n.title || "", id = n.id || "", tg = (n.portalItem && n.portalItem.tags) || [];
          const p = nodePath(n);
          if (isUtility(t,id,tg) || isWaterOrSewer(p)) continue;

          await n.load();

          const cnt = await countFeatures(n, geom);
          if (cnt <= 0) continue;

          const res = await legendFromRendererUsingFeatures(n, geom);
          const keys = res.items || [];
          const keyHTML = keys.length
            ? '<div class="leg" style="margin-top:4px">' + keys.map(function(k){
                return '<div class="row">'+k.swatchHTML+htmlEsc(k.label)+'</div>';
              }).join("") + '</div>'
            : "";

          const title = htmlEsc(t || "Layer");
          items.push(
            '<li>' +
               '<div class="ov-title">'+title+' <span style="color:#777">('+cnt+')</span></div>' +
               keyHTML +
            '</li>'
          );
        }catch(err){
          /* ignore layer errors */
        }
      }

      ul.innerHTML = items.length
        ? items.join("")
        : "<li><i>No overlays intersect this parcel.</i></li>";
    }

    async function focusOnParcelFeature(feat,{shouldZoom=false}={}){
      if(!feat || !feat.geometry) return;
      const geom = normalizeToWebMercator(projectToViewSR(feat.geometry));
      feat.geometry = geom;
      updateBadgesFromFeature(feat);
      selLayer.removeAll();
      if(geom.type==="point" || geom.type==="multipoint"){
        selLayer.add(new Graphic({geometry:geom,symbol:{type:"simple-marker",style:"circle",size:10,color:[167,11,19,0.2],outline:{color:"#a70b13",width:2}}}));
      }else{
        outlineSelection(geom);
      }
      await hideUnusedOverlaysFor(geom);
      try{
        const addr=await resolveBestAddress(geom, feat);
        lastParcelInfo.addressText=addr||lastParcelInfo.addressText||"Address unavailable";
        updateSummaryPanel();
      }catch(e){}
      updateSideOverlaySummary(geom);
      if(shouldZoom){
        try{
          if(geom.type==="point" || geom.type==="multipoint"){
            await view.goTo({target:geom, zoom:18});
          }else{
            const ext = geom.extent || framedExtent(geom);
            if(ext){
              await view.goTo({target:ext.expand(1.2), animate:true});
            }else if(geom.centroid){
              await view.goTo({target:geom.centroid, zoom:18});
            }else{
              await view.goTo({target:geom, zoom:18});
            }
          }
        }catch(err){
          console.warn("goTo failed", err);
        }
      }
    }

    view.on("click", async function(ev){
      try{
        showLoading(true);
        const parcel=await findParcelAtPoint(ev.mapPoint);
        if(!parcel){ selLayer.removeAll(); return; }
        await focusOnParcelFeature(parcel,{shouldZoom:true});
      } finally { showLoading(false); }
    });
  </script>

</body>
</html>
