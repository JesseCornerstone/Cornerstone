<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Moreton Bay Interactive Mapping</title>
<link rel="icon" type="image/png" href="./images/Flavour icon.png">
<link rel="preconnect" href="https://js.arcgis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>

<!-- ArcGIS JS CSS (4.34) -->
<link rel="stylesheet" href="https://js.arcgis.com/4.34/@arcgis/core/assets/esri/themes/light/main.css"/>

<!-- Embeddable map components (per your snippet) -->
<script type="module" src="https://js.arcgis.com/4.34/embeddable-components/"></script>
<link rel="preload" href="map-theme.css" as="style">

<style>
  :root{ --brand:#a70b13; --brand2:#7f0e15; --bg:#f6f7f9; --ink:#0b0d12; --border:#e1e3e6; --radius:14px; --shadow:0 6px 18px rgba(16,21,28,.08); }
  html,body{height:100%;margin:0}
  body{display:flex;flex-direction:column;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}

  header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 16px;color:#fff;background:linear-gradient(90deg,var(--brand),var(--brand2));box-shadow:var(--shadow)}
  .brand{font-weight:800;letter-spacing:.2px}
  .toolbar{display:flex;gap:10px;flex-wrap:wrap}
  .btn{border:none;border-radius:999px;padding:10px 14px;cursor:pointer;color:#fff;background:rgba(255,255,255,.14)}
  .btn:hover{background:rgba(255,255,255,.22)}
  .btn.linklike{background:transparent;border:1px solid rgba(255,255,255,.45)}

  #contextBar{display:flex;flex-wrap:wrap;gap:12px;align-items:center;padding:8px 16px;background:#fff;border-bottom:1px solid var(--border)}
  .badge{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);background:#fff;border-radius:999px;padding:4px 10px;font-size:12px}

  main{flex:1;min-height:0;display:grid;grid-template-columns:clamp(280px,24vw,420px) 1fr;gap:12px;padding:12px}
  #left{min-width:280px;background:#fff;border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);display:flex;flex-direction:column;overflow:auto;max-height:calc(100vh - 140px);height:calc(100vh - 140px);scrollbar-width:thin;scrollbar-color:#c7cbd1 transparent}
  #left::-webkit-scrollbar{ width: 8px; }
  #left::-webkit-scrollbar-thumb{ background:#c7cbd1; border-radius:6px; }
  #left::-webkit-scrollbar-track{ background:transparent; }
  .panel::-webkit-scrollbar{ width: 8px; }
  .panel::-webkit-scrollbar-thumb{ background:#c7cbd1; border-radius:6px; }
  .panel::-webkit-scrollbar-track{ background:transparent; }
  #viewWrap{position:relative;border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden}
  #viewDiv{position:absolute;inset:0}

  .panel{display:none;padding:12px;overflow:auto;max-height:calc(100vh - 200px)}
  .panel.active{display:block}
  .pod-form{display:flex;flex-direction:column;gap:8px;margin-top:6px}
  .pod-form input[type="file"]{display:none}
  .pod-upload-row{display:flex;align-items:center;gap:10px}
  .pod-upload-btn{display:inline-flex;align-items:center;gap:6px;padding:10px 14px;border-radius:12px;border:1px solid #d0d4dc;background:#fff;color:var(--ink);font-weight:600;font-size:13px;cursor:pointer;box-shadow:inset 0 1px 0 rgba(255,255,255,.6),0 1px 3px rgba(0,0,0,.08)}
  .pod-upload-btn:hover{border-color:#b3b9c6;background:#f7f9fc}
  .pod-drop{border:1px dashed #c5cad3;border-radius:12px;padding:10px;transition:background .2s,border-color .2s}
  .pod-drop.dragover{background:#f2f5fb;border-color:#7f9ad5}
  .pod-file-name{font-size:13px;color:#6b7280;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .pod-form .btn.full{width:100%;text-align:center}
  .pod-status{font-size:12px;color:#4b5563;margin-top:6px;min-height:18px}
  .pod-status.error{color:#b42318}
  .pod-results{margin-top:10px;border-top:1px solid var(--border);padding-top:8px;max-height:200px;overflow-y:auto;overflow-x:hidden}
  .pod-results ul{margin:0;padding-left:18px;font-size:13px}
  .pod-result-row{display:flex;align-items:center;gap:8px;margin:6px 0}
  .pod-zoom-btn{border:1px solid #d0d4dc;background:#f7f9fc;border-radius:10px;padding:6px 10px;font-size:12px;cursor:pointer}
  .pod-zoom-btn:hover{background:#eef2f7;border-color:#b3b9c6}
  .pod-details{max-height:280px;overflow:auto}
  .pod-details summary{cursor:pointer;font-weight:600;font-size:15px;list-style:none}
  .pod-details summary::-webkit-details-marker{display:none}
  .pod-details summary::after{content:"+";float:right;font-size:12px;color:#666}
  .pod-details[open] summary::after{content:"-"}
  /* Darken POD panel to align with map-theme */
  #podUploadCard{background:var(--map-panel,#1b1c20);border:1px solid var(--map-border,#2b2c33);color:var(--map-ink,#f5f5f8);}
  #podUploadCard .section-title,#podUploadCard summary{color:var(--map-ink,#f5f5f8);}
  #podUploadCard p,#podUploadCard .pod-status,#podUploadCard .pod-file-name{color:var(--map-muted,#9ea1ab);}
  #podUploadCard .pod-result-row{color:var(--map-ink,#f5f5f8);}
  #podUploadCard .pod-results{border-color:var(--map-border,#2b2c33);}
  #podUploadCard .pod-zoom-btn{background:var(--map-panel-2,#262628);border-color:var(--map-border,#2b2c33);color:var(--map-ink,#f5f5f8);}
  #podUploadCard .pod-zoom-btn:hover{background:var(--map-panel,#1b1c20);border-color:var(--map-accent,#c03b41);}
  #podUploadCard .pod-upload-btn{background:var(--map-panel-2,#262628);border-color:var(--map-border,#2b2c33);color:var(--map-ink,#f5f5f8);}
  #podUploadCard .pod-upload-btn:hover{background:var(--map-panel,#1b1c20);border-color:var(--map-accent,#c03b41);}
  #podUploadCard .pod-drop{border-color:var(--map-border,#2b2c33);background:var(--map-panel-2,#262628);}
  #podUploadCard .pod-drop.dragover{background:var(--map-panel,#1b1c20);border-color:var(--map-accent,#c03b41);}
  #podUploadCard .btn.full{background:var(--map-accent,#c03b41);border:none;color:#fff;}
  #podUploadCard .btn.full:hover{background:var(--map-accent-dark,#9e2c32);}

  .pod-aligner{margin-top:10px;border-top:1px solid var(--map-border,#2b2c33);padding-top:10px}
  .pod-aligner canvas{width:100%;max-width:420px;border:1px solid var(--map-border,#2b2c33);border-radius:10px;background:#111;margin-bottom:8px;cursor:crosshair}
  .pod-aligner .pod-align-actions{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .pod-aligner .pod-hint{font-size:12px;color:var(--map-muted,#9ea1ab);margin:4px 0}
  .pod-aligner .chip{display:inline-flex;align-items:center;gap:6px;font-size:12px;border:1px solid var(--map-border,#2b2c33);padding:4px 8px;border-radius:999px;background:var(--map-panel-2,#262628);color:var(--map-ink,#f5f5f8);}
  .pod-aligner select{background:var(--map-panel-2,#262628);color:var(--map-ink,#f5f5f8);border:1px solid var(--map-border,#2b2c33);border-radius:8px;padding:6px 8px;font-size:12px}
  .trace-controls{margin-top:10px;padding:10px;border:1px dashed var(--map-border,#2b2c33);border-radius:10px;background:var(--map-panel-2,#262628);color:var(--map-ink,#f5f5f8);display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .trace-controls .trace-status{font-size:12px;color:var(--map-muted,#9ea1ab)}
  #statusBar{display:flex;gap:24px;align-items:center;padding:6px 16px;background:#fff;border-top:1px solid var(--border);color:#555;font-size:12px}

  #loadingMask{position:absolute;inset:0;background:rgba(255,255,255,.65);display:none;align-items:center;justify-content:center;z-index:6}
  .spinner{width:64px;height:64px;border-radius:50%;border:6px solid rgba(167,11,19,.25);border-top-color:#a70b13;animation:spin 1s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}

  .card{border:1px solid #e1e3e6;border-radius:12px;padding:14px;margin:10px 0;background:#fff;box-shadow:0 2px 10px rgba(16,21,28,.05)}
  .brandbar{display:flex;align-items:center;gap:12px;padding:14px 16px;margin:-14px -14px 14px -14px;color:#fff;background:linear-gradient(90deg,var(--brand),var(--brand2));border-radius:12px 12px 0 0}
  .brandbar img{width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,.6);background:#fff}
  .brandbar h1{margin:0;font-size:18px;font-weight:800;letter-spacing:.2px}
  .brandbar .muted{margin-left:auto;opacity:.95;font-weight:600}

  .rpt-grid{display:grid;grid-template-columns:1fr 1.25fr;gap:18px}
  .propmap{grid-column:1 / -1}
  .propmap-grid{display:grid;grid-template-columns:1fr 1.6fr;gap:16px;align-items:start}
  .badge-pill{display:inline-block;border:1px solid #dadde2;border-radius:999px;padding:4px 10px;margin:4px 6px 0 0;background:#fafbfc}
  .kv{margin-top:8px;font-size:14px;color:#333}.kv div{margin:4px 0}
  img.map{max-width:100%;border:1px solid #e6e8ec;border-radius:10px}

  .section-title{margin:0 0 10px;font-size:18px}
  .overlay-header{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .backbtn{display:inline-block;border:1px solid #d7d7d7;border-radius:999px;padding:6px 10px;font-size:12px;color:#333;text-decoration:none;background:#f7f7f7}
  .backbtn:hover{background:#eee}

  .sumlist{margin:6px 0 0 18px;padding:0}.sumlist li{margin:8px 0 12px}
  .note{margin-top:8px;font-size:13px;color:#7a0f16;font-weight:700}
  .rpt-footer{margin-top:14px;padding-top:8px;border-top:1px dashed #ddd;font-size:12px;color:#555}

  .leg{font-size:13px;line-height:1.35;margin-top:8px}
  .leg .row{display:flex;align-items:center;gap:8px;margin:2px 0}
  .leg .swbox{display:inline-flex;align-items:center;justify-content:center;width:16px;height:14px;padding:1px;border:1px solid #999;border-radius:3px;overflow:hidden;background:#fff}
  .leg .swbox img,.leg .swbox svg,.leg .swbox canvas{width:100%;height:100%;display:block;object-fit:contain}

  @media print{*{-webkit-print-color-adjust:exact!important;print-color-adjust:exact!important}.card{page-break-inside:avoid}}

  #rptOverlay{position:fixed;inset:0;display:none;z-index:9999;background:rgba(246,247,249,.94);-webkit-backdrop-filter:saturate(1.2) blur(2px);backdrop-filter:saturate(1.2) blur(2px);place-items:center;padding:24px}
  #rptCard{width:min(880px,92vw);border:1px solid #e6e8ec;border-radius:16px;background:#fff;box-shadow:0 20px 48px rgba(16,21,28,.12)}
  #rptBrand{display:flex;align-items:center;gap:12px;color:#fff;background:linear-gradient(90deg,#a70b13,#7f0e15);padding:14px 16px;border-radius:16px 16px 0 0}
  #rptBrand img{width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,.6);background:#fff}
  #rptBrand h1{margin:0;font-size:18px;font-weight:800;letter-spacing:.2px}
  #rptBody{padding:16px}
  #rptStatus{display:flex;align-items:center;gap:10px;color:#344054}
  #rptRing{width:22px;height:22px;border:3px solid #e8e8ee;border-top-color:#a70b13;border-radius:50%;animation:spin 1s linear infinite}
  #rptProgress{height:8px;background:#eef0f4;border-radius:999px;overflow:hidden;margin-top:10px}
  #rptBar{height:100%;width:0%;background:linear-gradient(90deg,#a70b13,#df5056);transition:width .25s ease;border-radius:999px}
  #rptSteps{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:12px}
  .rptStep{background:#fbfbfc;border:1px dashed #e2e4e8;border-radius:10px;padding:10px;font-size:12px;color:#475467}
  .rptDone{border-color:#cfe6d2;background:#f2faf3;color:#1e7a31;font-weight:600}

  /* Payment access gate */
  #accessGate{
    position:fixed;
    inset:0;
    display:none;
    z-index:10000;
    background:rgba(12,14,18,.78);
    backdrop-filter:blur(3px);
    color:#f6f7fb;
    place-items:center;
    padding:24px;
  }
  #accessGate.active{display:grid;}
  .gate-card{
    width:min(560px,92vw);
    background:#14161b;
    border:1px solid #2b2f38;
    border-radius:18px;
    padding:22px 24px;
    box-shadow:0 24px 60px rgba(0,0,0,.5);
  }
  .gate-title{margin:0 0 8px;font-size:20px;letter-spacing:.2px}
  .gate-msg{margin:0 0 14px;color:#c8cbd6;font-size:14px}
  .gate-timer{display:inline-flex;gap:6px;align-items:center;font-size:13px;color:#c03b41;background:#1b1d24;border:1px solid #2f333d;border-radius:999px;padding:6px 10px;margin-bottom:14px}
  .gate-actions{display:flex;gap:10px;flex-wrap:wrap}
  .gate-btn{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    border:none;
    border-radius:999px;
    padding:10px 16px;
    background:#c03b41;
    color:#fff;
    cursor:pointer;
    text-decoration:none;
    font-weight:600;
  }
  .gate-btn.secondary{
    background:transparent;
    border:1px solid #3a3f4c;
    color:#e3e6ef;
  }

  #sumOverlays{max-height:320px;overflow:auto;padding-right:6px;scrollbar-width:thin;scrollbar-color:#c7cbd1 transparent}
  #sumOverlays::-webkit-scrollbar{width:8px}
  #sumOverlays::-webkit-scrollbar-thumb{background:#c7cbd1;border-radius:6px}
  #sumOverlays::-webkit-scrollbar-track{background:transparent}

  /* Utility toggle button */
  .util-toggle-btn{
    width:34px;height:34px;
    display:inline-flex;align-items:center;justify-content:center;
    border:1px solid #7a7f85;border-radius:3px;
    background:#ffffff;box-shadow:0 1px 2px rgba(0,0,0,.22);
    padding:0;cursor:pointer;opacity:1;transition:background-color .15s ease,box-shadow .15s ease;
  }
  #btnUtilityToggleMap.util-toggle-btn,
  #btnUtilityToggleMap.util-toggle-btn.esri-widget--button{
    background:#ffffff !important;
    border-color:#7a7f85 !important;
    opacity:1 !important;
  }
  .util-toggle-btn:hover{ background:#f3f4f6; box-shadow:0 1px 3px rgba(0,0,0,.28); }
  .util-toggle-btn svg{ width:18px;height:18px; }
  .util-toggle-btn svg path,.util-toggle-btn svg rect{ stroke:#2b3138; fill:none; stroke-linejoin:round; stroke-width:1.25; }
  .util-toggle-btn.active,
  .util-toggle-btn:active{ background:#e9ebef; box-shadow:inset 0 0 0 1px rgba(0,0,0,.08); }
  </style>
<link rel="stylesheet" href="map-theme.css">
</head>
<body>
  <header>
    <div class="brand-logo"><img src="./images/250916 Cornerstone Logo.png" alt="Cornerstone" style="height:64px"></div>
    <div class="toolbar">
      <button id="btnHome" class="btn linklike" title="Back to index">Home</button>
      <button id="btnPrintReport" class="btn">Print Report</button>
    </div>
  </header>

  <main>
    <aside id="left">
      <div class="side-heading">
        <div class="side-heading-title">MORETON BAY INTERACTIVE MAPPING</div>
      </div>
      <section id="panel-summary" class="panel active" role="tabpanel" aria-labelledby="tab-summary">
        <button class="tab" id="tab-summary"  role="tab" aria-selected="true"  aria-controls="panel-summary">Summary</button>
        <div class="card">
          <h2 class="section-title">Property</h2>
          <div class="kv">
            <div><b>Lot/Plan:</b> <span id="sumLot">--</span></div>
            <div><b>Area:</b> <span id="sumArea">-- m</span></div>
            <div><b>Class:</b> <span id="sumClass">--</span></div>
            <div><b>Address:</b> <span id="sumAddress">--</span></div>
            <div><b>Council:</b> <span id="sumCouncil">Moreton Bay Regional Council</span></div>
          </div>
        </div>
        <div class="card">
          <h2 class="section-title">Overlays</h2>
          <ul id="sumOverlays" class="sumlist"><li><i>Select a parcel...</i></li></ul>
        </div>
        <div class="card" id="podUploadCard">
          <details class="pod-details" id="podDetails">
            <summary>POD Import</summary>
            <p style="margin-top:10px;font-size:13px;color:#4b5563">Upload a POD PDF to auto-detect subdivisions. ArcGIS uploads will be enabled next.</p>
            <form id="podForm" class="pod-form">
              <div class="pod-upload-row pod-drop" id="podDropZone">
                <label for="podFile" class="pod-upload-btn">Choose file</label>
                <div id="podFileName" class="pod-file-name">No file chosen</div>
              </div>
              <input type="file" id="podFile" accept="application/pdf" required>
              <button type="submit" id="podSubmitBtn" class="btn full">Upload &amp; Import</button>
            </form>
            <div id="podStatus" class="pod-status">Select a POD PDF to begin.</div>
            <div id="podResultWrap" class="pod-results" hidden>
              <strong style="font-size:13px;display:block;margin-bottom:4px">Detected Subdivisions</strong>
              <ul id="podResultList"></ul>
            </div>
            <div id="podAligner" class="pod-aligner" hidden>
              <div class="pod-hint">Pick 4 matching corners (best) or 2 points on the POD, then pick the same corners on the map. 4-point will auto-align without nudging.</div>
              <div class="pod-align-actions" style="margin-bottom:6px">
                <label style="font-size:12px">Page <select id="podPageSelect"></select></label>
                <span class="pod-hint" id="podPageInfo"></span>
              </div>
              <canvas id="podCanvas" width="600" height="420" aria-label="POD preview"></canvas>
              <div class="pod-align-actions">
                <button type="button" id="podStartAlignBtn" class="btn" style="background:#444">Pick points</button>
                <button type="button" id="podClearAlignBtn" class="btn linklike">Clear overlay</button>
                <span id="podAlignStatus" class="chip">Waiting for PDF...</span>
              </div>
              <div class="pod-align-actions">
                <span class="pod-hint">Nudge:</span>
                <button type="button" id="podRotateLeft" class="btn linklike" title="Rotate -2°">⟲ -2°</button>
                <button type="button" id="podRotateRight" class="btn linklike" title="Rotate +2°">⟳ +2°</button>
                <button type="button" id="podScaleDown" class="btn linklike" title="Scale -5%">-5%</button>
                <button type="button" id="podScaleUp" class="btn linklike" title="Scale +5%">+5%</button>
                <button type="button" id="podRefitBtn" class="btn linklike" title="Refit to picked points">Refit</button>
              </div>
              <div class="trace-controls">
                <button type="button" id="traceStartBtn" class="btn" style="background:#555">Start Trace</button>
                <button type="button" id="traceFinishBtn" class="btn linklike">Finish</button>
                <button type="button" id="traceUndoBtn" class="btn linklike">Undo</button>
                <button type="button" id="traceClearBtn" class="btn linklike">Clear</button>
                <span id="traceStatus" class="trace-status">Trace off.</span>
              </div>
              <div class="pod-align-actions">
                <button type="button" id="fitParcelBtn" class="btn linklike">Fit to selected parcel</button>
              </div>
            </div>
          </details>
        </div>
      </section>
    </aside>

    <div id="viewWrap">
      <div id="viewDiv"></div>
      <div id="loadingMask"><div class="spinner" aria-label="Loading…"></div></div>
    </div>
  </main>

  <div id="statusBar">
    <span id="statusCoords">Coords: --</span>
    <span id="statusZoom">Zoom: --</span>
    <span id="statusScale">Scale: --</span>
  </div>

  <div id="accessGate" aria-hidden="true">
    <div class="gate-card" role="dialog" aria-modal="true">
      <h2 id="accessGateTitle" class="gate-title">Access required</h2>
      <p id="accessGateMsg" class="gate-msg">A valid purchase is required to use this map.</p>
      <div class="gate-actions">
        <a id="accessPayLink" class="gate-btn" href="#" rel="noopener">Go to payment</a>
        <button id="accessGateHome" class="gate-btn secondary" type="button">Back to home</button>
      </div>
    </div>
  </div>

  <div id="rptOverlay" aria-hidden="true">
    <div id="rptCard">
      <div id="rptBrand">
        <img src="./images/Flavour icon.png" alt="Logo">
        <h1>MORETON BAY INTERACTIVE MAPPING - GENERATING REPORT</h1>
      </div>
      <div id="rptBody">
        <div id="rptStatus"><div id="rptRing"></div><div id="rptMsg">Starting…</div></div>
        <div id="rptProgress"><div id="rptBar"></div></div>
        <div id="rptSteps">
          <div class="rptStep" id="rptS1">Locate parcel</div>
          <div class="rptStep" id="rptS2">Resolve address</div>
          <div class="rptStep" id="rptS3">Render overlays</div>
          <div class="rptStep" id="rptS4">Compose document</div>
        </div>
        <div style="margin-top:10px;color:#667085;font-size:12px">Keep this tab visible while the report builds so map screenshots can render smoothly.</div>
        <div id="rptActions" style="margin-top:12px;display:none;gap:8px;align-items:center;">
          <button id="openReportBtn" class="btn" type="button">Open Report</button>
          <span id="rptReadyMsg" style="color:#344054;font-size:12px;">Report ready. Choose an option below.</span>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import Portal from "https://js.arcgis.com/4.34/@arcgis/core/portal/Portal.js";
    import WebMap from "https://js.arcgis.com/4.34/@arcgis/core/WebMap.js";
    import MapView from "https://js.arcgis.com/4.34/@arcgis/core/views/MapView.js";
    import Graphic from "https://js.arcgis.com/4.34/@arcgis/core/Graphic.js";
    import GraphicsLayer from "https://js.arcgis.com/4.34/@arcgis/core/layers/GraphicsLayer.js";
    import Search from "https://js.arcgis.com/4.34/@arcgis/core/widgets/Search.js";
    import Expand from "https://js.arcgis.com/4.34/@arcgis/core/widgets/Expand.js";
    import ScaleBar from "https://js.arcgis.com/4.34/@arcgis/core/widgets/ScaleBar.js";
    import Home from "https://js.arcgis.com/4.34/@arcgis/core/widgets/Home.js";
    import LayerList from "https://js.arcgis.com/4.34/@arcgis/core/widgets/LayerList.js";
    import Legend from "https://js.arcgis.com/4.34/@arcgis/core/widgets/Legend.js";
    import BasemapGallery from "https://js.arcgis.com/4.34/@arcgis/core/widgets/BasemapGallery.js";
    import Fullscreen from "https://js.arcgis.com/4.34/@arcgis/core/widgets/Fullscreen.js";
    import MediaLayer from "https://js.arcgis.com/4.34/@arcgis/core/layers/MediaLayer.js";
    import ImageElement from "https://js.arcgis.com/4.34/@arcgis/core/layers/support/ImageElement.js";
    import * as reactiveUtils from "https://js.arcgis.com/4.34/@arcgis/core/core/reactiveUtils.js";
    import * as geometryEngine from "https://js.arcgis.com/4.34/@arcgis/core/geometry/geometryEngine.js";
    import * as symbolUtils from "https://js.arcgis.com/4.34/@arcgis/core/symbols/support/symbolUtils.js";
    import * as locator from "https://js.arcgis.com/4.34/@arcgis/core/rest/locator.js";
    import esriConfig from "https://js.arcgis.com/4.34/@arcgis/core/config.js";

    /* ---------------- Tunables ---------------- */
    const TOUCH_BUFFER_M = 6;
    const SWATCH_PX = 16;
    const GEOCODER_URL = "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer";

    /* Updated to your Moreton Bay map’s center/scale */
    const GOLD_COAST_CENTER=[152.99920476178747,-27.204298647940345];
    const GOLD_COAST_SCALE=9027.977411;
    const M2="m²";
    const LOTPLAN_FALLBACK_URLS = [
      "https://spatial-gis.information.qld.gov.au/arcgis/rest/services/PlanningCadastre/LandParcelPropertyFramework/MapServer/0",
      "https://spatial-gis.information.qld.gov.au/arcgis/rest/services/PlanningCadastre/LandParcelPropertyFramework/MapServer/4",
      "https://services2.arcgis.com/dEKgZETqwmDAh1rP/arcgis/rest/services/property_boundaries_parcel/FeatureServer/0",
      "https://services2.arcgis.com/dEKgZETqwmDAh1rP/arcgis/rest/services/property_boundaries_holding/FeatureServer/0",
      "https://spatial-gis.information.qld.gov.au/arcgis/rest/services/Property/PropertyBoundaries/MapServer/0"
    ];

    const HOUSES_OUT = 3;
    const HOUSE_LOT_METERS = 25;
    const SCREEN_BUFFER_METERS = HOUSES_OUT * HOUSE_LOT_METERS;
    const SHOT_SIZE = { width: 1280, height: 900 };

    /* ---- CORS allow-list for address queries ---- */
    const CORS_HOSTS = [
      "cornerstonebc.maps.arcgis.com",
      "services.arcgis.com",
      "services2.arcgis.com",
      "gisservices.information.qld.gov.au",
      "gis.brisbane.qld.gov.au",
      "maps.moretonbay.qld.gov.au",
      "maps.goldcoast.qld.gov.au"
    ];
    CORS_HOSTS.forEach(h=>{
      try{
        const arr = esriConfig.request.corsEnabledServers;
        if (!arr.includes(h)) arr.push(h);
      }catch{}
    });

    /* ---------------- Small helpers ---------------- */
    const $=id=>document.getElementById(id);
    const setText=(id,t)=>{const el=$(id); if(el) el.textContent=t;};
    const showLoading=on=>{const m=$("loadingMask"); if(m) m.style.display=on?"flex":"none";};
    const raf=()=>new Promise(r=>requestAnimationFrame(()=>r()));
    const sleep=ms=>new Promise(r=>setTimeout(r,ms));
    const waitViewIdle=async(extra=240)=>{try{await reactiveUtils.whenOnce(()=>!view.updating);}catch{} await raf(); await sleep(extra);};

    /* ---------------- Access gate ---------------- */
    const accessState = {
      key: null,
      expiresAt: null,
      active: false,
      paymentUrl: null,
      countdownTimer: null
    };

    const PAYMENT_FALLBACK_URL = "https://buy.stripe.com/9B65kD0rQ7wJ95FaEx7ss0b";

    const getQueryParam = name=>{
      try{
        return new URLSearchParams(window.location.search).get(name);
      }catch{
        return null;
      }
    };

    const formatRemaining = ms=>{
      if(ms < 0) ms = 0;
      const total = Math.floor(ms / 1000);
      const h = Math.floor(total / 3600);
      const m = Math.floor((total % 3600) / 60);
      const s = total % 60;
      return h > 0
        ? `${h}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`
        : `${m}:${String(s).padStart(2,"0")}`;
    };

    const setGateVisible = on=>{
      const gate = $("accessGate");
      if(!gate) return;
      gate.classList.toggle("active", !!on);
      gate.setAttribute("aria-hidden", on ? "false" : "true");
    };

    const setGateMessage = (title, msg)=>{
      setText("accessGateTitle", title);
      setText("accessGateMsg", msg);
    };

    const setPaymentLink = url=>{
      const link = $("accessPayLink");
      if(link) link.href = url || PAYMENT_FALLBACK_URL;
    };

    const setTimerVisible = show=>{
      const timer = $("accessGateTimer");
      if(timer) timer.hidden = !show;
    };

    const loadPaymentUrl = async()=>{
      try{
        const res = await fetch("/api/payment-config", { cache: "no-store" });
        if(res.ok){
          const json = await res.json();
          if(json && json.paymentUrl) return json.paymentUrl;
        }
      }catch{}
      return null;
    };

    const checkToken = async key=>{
      try{
        const res = await fetch(`/api/check-token?key=${encodeURIComponent(key)}`, { cache: "no-store" });
        if(res.ok){
          const json = await res.json();
          return { ok: true, expiresAt: json.expiresAt };
        }
        const text = await res.text();
        let msg = "Access denied.";
        try{
          const parsed = JSON.parse(text);
          if(parsed && parsed.error) msg = parsed.error;
        }catch{}
        return { ok: false, error: msg };
      }catch{
        return { ok: false, error: "Access check failed." };
      }
    };

    const startCountdown = expiresAt=>{
      const expiry = new Date(expiresAt);
      const tick = ()=>{
        const ms = expiry - new Date();
        if(ms <= 0){
          stopCountdown();
          handleExpiry();
          return;
        }
        const el = $("accessCountdown");
        if(el) el.textContent = formatRemaining(ms);
      };
      tick();
      accessState.countdownTimer = setInterval(tick, 1000);
      setTimerVisible(true);
    };

    const stopCountdown = ()=>{
      if(accessState.countdownTimer){
        clearInterval(accessState.countdownTimer);
        accessState.countdownTimer = null;
      }
    };

    const handleExpiry = ()=>{
      accessState.active = false;
      setGateMessage("Session expired", "Your 24-hour access window has ended. Please purchase again to continue.");
      setGateVisible(true);
      setTimerVisible(false);
    };

    const initAccessGate = async()=>{
      accessState.key = getQueryParam("key");
      const sessionId = getQueryParam("session_id");
      accessState.paymentUrl = await loadPaymentUrl();
      setPaymentLink(accessState.paymentUrl || PAYMENT_FALLBACK_URL);

      const homeBtn = $("accessGateHome");
      if(homeBtn){
        homeBtn.addEventListener("click", ()=>{ window.location.href = "Index.html"; });
      }

      if(!accessState.key && sessionId){
        const returnPath = "MBRC.html";
        window.location.href = `/api/stripe/success?session_id=${encodeURIComponent(sessionId)}&return=${encodeURIComponent(returnPath)}`;
        return;
      }

      if(!accessState.key){
        setGateMessage("Payment required", "A valid purchase is required to use this map.");
        setGateVisible(true);
        setTimerVisible(false);
        return;
      }

      const result = await checkToken(accessState.key);
      if(!result.ok){
        setGateMessage("Access denied", result.error || "This access link is invalid or expired.");
        setGateVisible(true);
        setTimerVisible(false);
        return;
      }

      accessState.active = true;
      accessState.expiresAt = result.expiresAt;
      setGateVisible(false);
      startCountdown(result.expiresAt);
    };

    const isAccessActive = ()=>{
      if(!accessState.active || !accessState.expiresAt) return false;
      return new Date(accessState.expiresAt) > new Date();
    };

    const finalizeTokenAndLock = async()=>{
      if(!accessState.key){
        setGateMessage("Payment required", "A valid purchase is required to use this map.");
        setGateVisible(true);
        setTimerVisible(false);
        return;
      }
      try{
        await fetch(`/api/finalise-token?key=${encodeURIComponent(accessState.key)}`, { method: "POST" });
      }catch{}
      stopCountdown();
      accessState.active = false;
      setGateMessage("Payment required", "Access used. Please purchase again to continue.");
      setGateVisible(true);
      setTimerVisible(false);
    };

    initAccessGate();

    const slug=s=>String(s||"overlay").toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"");
    const htmlEsc=s=>String(s??"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");
    const attrEsc=s=>String(s??"").replace(/&/g,"&amp;").replace(/"/g,"&quot;");
    const PDF_WORKER_SRC="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    let pdfLibPromise=null;
    const ensurePdfjs=async()=>{
      if(window.pdfjsLib) return window.pdfjsLib;
      if(!pdfLibPromise){
        pdfLibPromise = new Promise((resolve,reject)=>{
          const script=document.createElement("script");
          script.src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
          script.crossOrigin="anonymous";
          script.referrerPolicy="no-referrer";
          script.onload=()=>{
            if(window.pdfjsLib){
              try{
                window.pdfjsLib.GlobalWorkerOptions.workerSrc=PDF_WORKER_SRC;
              }catch(e){
                console.warn("pdfjs worker init failed",e);
              }
              resolve(window.pdfjsLib);
            }else{
              reject(new Error("pdf.js did not load"));
            }
          };
          script.onerror=()=>reject(new Error("Failed to load pdf.js"));
          document.head.appendChild(script);
        });
      }
      return pdfLibPromise;
    };

    async function extractPdfText(file){
      if(!file) throw new Error("No file selected");
      await ensurePdfjs();
      if(!window.pdfjsLib) throw new Error("PDF parser not available");
      const buffer = await file.arrayBuffer();
      const pdf = await window.pdfjsLib.getDocument({data:buffer}).promise;
      let text="";
      for(let i=1;i<=pdf.numPages;i++){
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        const strings = content.items.map(item=>item.str||"").filter(Boolean);
        text += strings.join(" ") + "\n";
      }
      return text;
    }

    function parseSubdivisionsFromText(text){
      if(!text) return [];
      const lines = text.split(/\r?\n/).map(t=>t.trim()).filter(Boolean);
      const subdivisions=[];
      const planRegex=/\b((?:SP|RP|CP|BUP|SL|DP|SPRP)\s*-?\s*\d+)\b/i;
      const planLooseRegex=/((?:SP|RP|CP|BUP|SL|DP|SPRP)\s*-?\s*\d+)/i;
      const lotRegex=/\b(?:lot|lot\s*no\.?)\s*[:#-]?\s*([0-9A-Za-z-]+)\b/i;
      const comboRegex=/(\d+[A-Za-z-]?)(?:\s*(?:\/|on)\s*|\s*)((?:SP|RP|CP|BUP|SL|DP|SPRP)\s*-?\s*\d+)/i;
      const areaRegex=/(\d{1,3}(?:,\d{3})*(?:\.\d+)?)\s*(?:m2|m\u00b2|sqm|square metres?)/i;

      const addUnique=(lot,plan,areaSqm,raw)=>{
        const key=`${lot||""}_${plan||""}`;
        if(!subdivisions.some(sub=>`${sub.lot}_${sub.plan}`===key)){
          subdivisions.push({lot:lot||null,plan:plan||null,areaSqm:areaSqm??null,raw});
        }
      };
      const traceState={
        active:false,
        points:[],
        handle:null,
        preview:null
      };
      const addTraceMarker = (pt)=>{
        try{
          podMarkerLayer.add(new Graphic({
            geometry: pt,
            symbol:{type:"simple-marker", style:"cross", color:[0,200,0,1], size:12, outline:{color:"#fff", width:1}}
          }));
        }catch{}
      };

      // Global scans to catch obvious "Lot X on PLAN" or "X / PLAN" mentions
      [...text.matchAll(/\bLot\s+(\d+[A-Za-z-]?)\s+on\s+((?:SP|RP|CP|BUP|SL|DP|SPRP)\s*-?\s*\d+)\b/ig)]
        .forEach(m=> addUnique(m[1].toUpperCase(), m[2].replace(/[\s-]+/g,"").toUpperCase(), null, m[0]));
      [...text.matchAll(/\b(\d+[A-Za-z-]?)\s*(?:\/|on)?\s*((?:SP|RP|CP|BUP|SL|DP|SPRP)\s*-?\s*\d+)\b/ig)]
        .forEach(m=> addUnique(m[1].toUpperCase(), m[2].replace(/[\s-]+/g,"").toUpperCase(), null, m[0]));

      let current=null;
      const pushCurrent=()=>{
        if(!current) return;
        if(!current.lot && !current.plan) return;
        if(typeof current.areaSqm!=="number"||!Number.isFinite(current.areaSqm)){
          current.areaSqm=null;
        }
        addUnique(current.lot, current.plan, current.areaSqm, current.raw);
      };

      for(const line of lines){
        const normalized=line.replace(/\s+/g," ");
        const lotMatch=normalized.match(lotRegex);
        let planMatch=normalized.match(planRegex);
        if(!planMatch) planMatch=normalized.match(planLooseRegex);
        const comboMatch=normalized.match(comboRegex);
        const areaMatch=normalized.match(areaRegex);

        let candidateLot=null;
        let candidatePlan=null;
        if(comboMatch){
          candidateLot=comboMatch[1].toUpperCase();
          candidatePlan=comboMatch[2].replace(/[\s-]+/g,"").toUpperCase();
        }
        if(lotMatch){
          candidateLot=lotMatch[1].toUpperCase();
        }
        if(planMatch){
          candidatePlan=planMatch[1].replace(/[\s-]+/g,"").toUpperCase();
          if(!candidateLot && typeof planMatch.index==="number"){
            const prefix=normalized.slice(0, planMatch.index).trim();
            const inline=prefix.match(/(\d+[A-Za-z-]?)/);
            if(inline){
              candidateLot=inline[1].toUpperCase();
            }
          }
        }

        const shouldStartNew=!current||
          (candidateLot&&current.lot&&candidateLot!==current.lot)||
          (candidatePlan&&current.plan&&candidatePlan!==current.plan);

        if(shouldStartNew){
          pushCurrent();
          current={lot:null,plan:null,areaSqm:null,raw:normalized};
        }else if(current){
          current.raw=normalized;
        }else{
          current={lot:null,plan:null,areaSqm:null,raw:normalized};
        }

        if(candidateLot){
          current.lot=candidateLot;
        }
        if(candidatePlan){
          current.plan=candidatePlan;
        }
        if(areaMatch){
          const parsed=Number(areaMatch[1].replace(/,/g,""));
          if(!Number.isNaN(parsed)){
            current.areaSqm=parsed;
          }
        }
      }
      pushCurrent();
      return subdivisions;
    }

    function framedExtent(geom){
      try{
        const b=geometryEngine.buffer(geom,SCREEN_BUFFER_METERS,"meters");
        return (b&&b.extent)?b.extent:(geom&&geom.extent);
      }catch{return geom && geom.extent;}
    }
    async function withViewOnGeom(geom,fn){
      const vp=view.viewpoint?.clone?.();
      try{
        if(geom?.extent){
          const target=framedExtent(geom);
          await view.goTo(target,{animate:false});
          await waitViewIdle(260);
        }
        return await fn();
      } finally {
        if(vp){ try{ await view.goTo(vp,{animate:false}); await waitViewIdle(160);}catch{} }
      }
    }
    const centroidOf = (g)=>{
      try{
        if (g?.centroid) return g.centroid;
        if (g?.extent?.center) return g.extent.center;
      }catch{}
      return null;
    };
    const projectToViewSR = (geom)=>{
      try{
        if(!geom || !view?.spatialReference) return geom;
        if(!geom.spatialReference){
          geom.spatialReference = { wkid: 102100 };
        }
        const gSR = geom.spatialReference?.wkid || geom.spatialReference?.latestWkid;
        const vSR = view.spatialReference?.wkid || view.spatialReference?.latestWkid;
        if(gSR && vSR && gSR === vSR) return geom;
        const proj = geometryEngine.project(geom, view.spatialReference);
        return proj || geom;
      }catch{ return geom; }
    };
    function normalizeToWebMercator(geom){
      try{
        if(!geom) return geom;
        const sr = geom.spatialReference?.wkid || geom.spatialReference?.latestWkid;
        if(sr===102100 || sr===3857) return geom;
        const sample = geom.type==="point" ? geom :
          geom.type==="polyline" ? (geom.paths?.[0]?.[0]) :
          geom.type==="polygon" ? (geom.rings?.[0]?.[0]) : null;
        if(sample){
          const x = sample.x ?? sample[0], y = sample.y ?? sample[1];
          if(Math.abs(x)>180 || Math.abs(y)>90){
            geom.spatialReference = { wkid:102100 };
            return geom;
          }
        }
        const projected = geometryEngine.project(geom, {wkid:102100});
        return projected || geom;
      }catch{ return geom; }
    }

    /* ---------------- Map & rules ---------------- */
    const portal=new Portal({url:"https://cornerstonebc.maps.arcgis.com"});

    // Use your Moreton Bay WebMap item (from the embeddable snippet)
    let webmap=new WebMap({portalItem:{id:"d0b673c9a75d4659a05d627587489272",portal}});

    const selLayer=new GraphicsLayer({listMode:"hide"}); webmap.add(selLayer);

    const view=new MapView({
      container:"viewDiv",
      map:webmap,
      center:GOLD_COAST_CENTER,
      zoom:17,
      constraints:{snapToZoom:false}
    });

    const inText=(t,p="")=>String(t||"")+" "+String(p||"");
    const isDNT=(title,id="",tags=[])=>{const t=String(title||""); const i=String(id||""); const tag=(tags||[]).join("|"); return /do[\s-]*not[\s-]*touch/i.test(t)||/do[\s-]*not[\s-]*touch/i.test(i)||/do[\s-]*not[\s-]*touch/i.test(tag);};
    const isWetland=(t,p="")=>/\b(wetland|wetlands|mangrove|saltmarsh|tidal|estuar(y|ies))\b/i.test(inText(t,p));
    const isUtility=(title,id="",tags=[],path="")=>{
      const hay = inText(title,id)+" "+(tags||[]).join(" ");
      if(isWetland(title,path)) return false;
      if(/waterway|watercourse/i.test(inText(title,path))) return false;
      return /\b(utilit(y|ies)|power|electric|telecom|gas|sewer|storm[-\s]?water|reticulation|service)\b/i.test(hay)
        || /\bwater\s*(main|mains|supply|network|pipe|retic)\b/i.test(hay);
    };
    const isWaterOrSewer=(path)=>{ const hay=String(path||""); if(/wetland|waterway|watercourse/i.test(hay)) return false; return /\b(sewer|wastewater|sewerage|storm\s*water|stormwater|water\s*(main|mains|supply|network|pipe|retic)|hydrant)\b/i.test(hay); };
    const isAcid=(t,p="")=>/\bacid\b/i.test(inText(t,p));
    const isTransport=(t,p="")=>{
      if(isNoise(t,p)) return false;
      return /\b(transport|road|rail|corridor|traffic|cycle|bikeway|pedestrian|carpark|parking|transit|bus|ferry)\b/i.test(inText(t,p));
    };
    const isAir=(t,p="")=>/\b(air\s*quality|air-quality|air|pollution)\b/i.test(inText(t,p));
    const isNoise=(t,p="")=>/\b(noise|acoustic|transport.*noise.*corridor|tnc)\b/i.test(inText(t,p));
    const isZoning=(t,p="")=>/\b(zoning|zone|zones)\b/i.test(inText(t,p));
    const isBushfire=(t,p="")=>/\b(bush[-\s]?fire|bushfire|bush\s*fire|wild[-\s]?fire|fire\s*hazard)\b/i.test(inText(t,p));

    const kidsOf=n=>(n.layers?.toArray?.()??n.layers)||(n.sublayers?.toArray?.()??n.sublayers)||[];
    const featureLayerCache=new WeakMap();
    async function featureLayerFor(node){
      if(!node || typeof node.createFeatureLayer!=="function") return null;
      if(featureLayerCache.has(node)) return featureLayerCache.get(node);
      try{
        const fl=await node.createFeatureLayer();
        await fl?.load?.();
        featureLayerCache.set(node,fl);
        return fl;
      }catch{
        featureLayerCache.set(node,null);
        return null;
      }
    }
        const nodePath=n=>{const bits=[]; let cur=n; while(cur){bits.unshift(cur.title||cur.id||"node"); cur=cur.parent;} return bits.join(" / ");};
    const ALWAYS_ON_IDS=new Set();
    const utilityVisSnapshot = new Map();
    let utilitiesToggleState = false;
    let utilToggleBtn = null;

    function walkAny(node,cb,inheritedDNT=false){
      if(!node) return;
      const t=node.title||node.id||"", id=node.id||"", tg=node.portalItem?.tags||[];
      const flag=inheritedDNT||isDNT(t,id,tg);
      cb(node,flag);
      (kidsOf(node)||[]).forEach(ch=>walkAny(ch,cb,flag));
    }
    function getUtilityNodes(){
      const nodes=[];
      walkAny(view.map,(n,underDNT)=>{
        if(underDNT || !("visible" in n)) return;
        const t=n.title||"", p=nodePath(n), tg=n.portalItem?.tags||[];
        if(isUtility(t,n.id,tg,p) || isWaterOrSewer(p)) nodes.push(n);
      });
      return nodes;
    }
    function updateUtilityToggleLabel(){
      const btn = utilToggleBtn || document.getElementById("btnUtilityToggleMap");
      if(!btn) return;
      const on = utilitiesToggleState;
      btn.setAttribute("title", on ? "Hide utilities" : "Show utilities");
      btn.setAttribute("aria-pressed", String(on));
      btn.classList.toggle("active", on);
    }
    function setUtilitiesVisible(on){
      const nodes=getUtilityNodes();
      if(on){
        utilityVisSnapshot.clear();
        nodes.forEach(n=>{
          if(!utilityVisSnapshot.has(n)) utilityVisSnapshot.set(n, !!n.visible);
          try{ n.visible=true; }catch{}
          try{ n.listMode="show"; }catch{}
          let p=n.parent;
          while(p){
            if("visible" in p){ try{p.visible=true;}catch{} }
            p=p.parent;
          }
        });
      }else{
        nodes.forEach(n=>{
          const prev = utilityVisSnapshot.has(n) ? utilityVisSnapshot.get(n) : false;
          try{ n.visible=prev; }catch{}
        });
      }
      utilitiesToggleState = on;
      updateUtilityToggleLabel();
      try{ layerList.refresh(); }catch{}
    }
    function keepOnHidden(node){ if("visible"in node){try{node.visible=true;}catch{}} if("listMode"in node){try{node.listMode="hide";}catch{}} try{node.minScale=0;node.maxScale=0;}catch{} if(node.type==="sublayer"){ try{ node.updateFromJSON({minScale:0,maxScale:0}); }catch{} } let p=node.parent; while(p){ if("visible"in p){try{p.visible=true;}catch{}} p=p.parent; } }
    function startHidden(node){ if("visible"in node){try{node.visible=false;}catch{}} if("listMode"in node){try{node.listMode="show";}catch{} }}
    function enforceOverlayRules(){ walkAny(webmap,(node,underDNT)=>{ if(node.type==="graphics"){try{node.listMode="hide";}catch{} return;} if(!("visible"in node)) return; underDNT?keepOnHidden(node):startHidden(node); }); }
    ;[300,900,1800,3500].forEach(ms=> setTimeout(()=>{ try{enforceOverlayRules();}catch{} },ms));
    (async()=>{ showLoading(true); try{ await webmap.loadAll(); enforceOverlayRules(); }catch(e){ console.warn("WebMap auth/fail; fallback basemap",e); webmap=new WebMap({basemap:"streets-vector"}); webmap.add(selLayer); view.map=webmap; } finally{ showLoading(false);} })();
view.ui.add(new Home({view}),"top-left");
    view.ui.add(new ScaleBar({view,unit:"metric"}),"bottom-left");
    const layerList=new LayerList({view,listItemCreatedFunction(e){
      const item=e.item, node=item.sublayer||item.layer;
      if(!node) return;
      if(node.type==="graphics"){ item.visible=false; item.panel=null; try{node.listMode="hide";}catch{} return; }
      let cur=node, inDNT=false;
      while(cur){ const t=cur.title||"", i=cur.id||"", tg=cur.portalItem?.tags||[]; if(isDNT(t,i,tg)){ inDNT=true; break; } cur=cur.parent; }
      if(inDNT){ keepOnHidden(node); item.visible=false; item.panel=null; }
      else{ try{node.listMode="show";}catch{} item.visible=true; item.panel={content:"legend"}; }
    }});
    view.ui.add(new Expand({view,content:layerList,expandIconClass:"esri-icon-layers",expanded:false}),"top-right");

    utilToggleBtn = (()=>{
      const btn=document.createElement("button");
      btn.id="btnUtilityToggleMap";
      btn.type="button";
      btn.className="esri-widget esri-widget--button util-toggle-btn";
      btn.innerHTML=`<svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
        <path d="M12 3.5c-3.2 4-5.5 7.2-5.5 9.7A5.5 5.5 0 0 0 12 18.7a5.5 5.5 0 0 0 5.5-5.5c0-2.5-2.3-5.7-5.5-9.7z"></path>
      </svg>`;
      btn.addEventListener("click",()=> setUtilitiesVisible(!utilitiesToggleState));
      updateUtilityToggleLabel();
      return btn;
    })();
    view.ui.add(utilToggleBtn,{position:"top-right",index:1});

    
    view.ui.add(new Expand({view,content:new Legend({view}),expandIconClass:"esri-icon-legend"}),"top-right");
    view.ui.add(new Expand({view,content:new BasemapGallery({view}),expandIconClass:"esri-icon-basemap"}),"top-right");
    view.ui.add(new Fullscreen({view}),"top-right");

    /* --- Search widget --- */
    const search=new Search({
      view,
      includeDefaultSources:true,
      popupEnabled:true,
      allPlaceholder:"Search address or Lot/Plan (e.g., 12/SP12345)"
    });
    view.ui.add(search,{position:"top-right",index:0});

    /* ---------------- Status ---------------- */
    view.watch("extent",()=>{ const c=view.center; setText("statusCoords",`Coords: ${c.longitude.toFixed(5)}, ${c.latitude.toFixed(5)}`); setText("statusZoom",`Zoom: ${view.zoom.toFixed(1)}`); setText("statusScale",`Scale: 1:${Math.round(view.scale)}`); });

    /* ---------------- Parcel selection ---------------- */
    const parseNumberLike=raw=>{ if(raw==null) return null; let s=String(raw).trim(); if(!s) return null; const hasHA=/(^|[^a-z])ha([^a-z]|$)/i.test(s)||/\bhectare(s)?\b/i.test(s); s=s.replace(/,/g,"").replace(/square\s*met(re|er)s?/ig,"").replace(/m2|m\u00B2|sqm|sq\.?m/ig,"").trim(); let n=parseFloat(s); if(isNaN(n)) return null; if(hasHA) n*=10000; return n; };
    function getLotAreaSqm(attrs){ const strong=["LOT_AREA_M2","LOT_SIZE_M2","LOT_SIZE_SQM","LOT_AREA_SQM","AREA_SQM","SITE_AREA_SQM","LAND_AREA_SQM","LOT_AREA","LOT_SIZE","SITE_AREA","LAND_AREA","AREA_M2","AREA (M2)","AREA(M2)","AREA_M^2","AREA_HA","HECTARES"]; for(const k of strong){ const v=k in attrs?parseNumberLike(attrs[k]):null; if(v!=null){ if(v>0&&v<50&&(k==="AREA_HA"||k==="HECTARES")) return v*10000; return v; } } for(const k2 in attrs){ const v2=attrs[k2]; if(/(lot|site|land).*area/i.test(k2)||/area.*(sqm|m2|m\^2|square)/i.test(k2)||(/(lot|site).*size/i.test(k2))){ const val=parseNumberLike(v2); if(val) return val; } } return null; }
    function parseParcelMeta(attrs){ const keys=rx=>Object.keys(attrs).find(k=>rx.test(k)); const lot=attrs["LOT"]??attrs["LOTNO"]??attrs["LOT_NO"]??attrs["LOTNUMBER"]??(keys(/^lot[\w_]*$/i)&&String(attrs[keys(/^lot[\w_]*$/i)])); const plan=attrs["PLAN"]??attrs["PLANNO"]??attrs["PLAN_NO"]??(keys(/^plan[\w_]*$/i)&&String(attrs[keys(/^plan[\w_]*$/i)])); let lotplan=attrs["LOT_PLAN"]??attrs["LOT_PLAN_NO"]??attrs["LOTPLAN"]??attrs["LOTPLAN_NO"]??attrs["LOTPLAN_TXT"]??attrs["LOT_PLAN_TXT"]??attrs["LOT_PLAN_TEXT"]??attrs["LOTPLAN_TEXT"]; if(!lotplan && lot && plan) lotplan=lot+"/"+plan; if(!lotplan){ for(const key in attrs){ const s=String(attrs[key]||"").toUpperCase(); const m=s.match(/\b(\d+)\s*\/\s*([A-Z]{1,4}\s*\d{1,8})\b/); if(m){ lotplan=m[1]+"/"+m[2].replace(/\s+/g,""); break; } } } return {lot,plan,lotplan}; }
    const geomAreaSqmSafe=g=>{ try{ const a=Math.abs(geometryEngine.planarArea(g,"square-meters")||0); return a>0?a:null; }catch{ return null; } };
    const normalizePlanCode=p=>{
      let s=String(p||"").toUpperCase().replace(/[^A-Z0-9]/g,"");
      s=s.replace(/^([A-Z]+)0+/, "$1");
      return s;
    };
    const normalizeLotPlanVal=s=>{
      // Lot numbers are digits only; strip all non-digits and leading zeros
      return String(s||"").replace(/[^0-9]/g,"").replace(/^0+/,"");
    };
    function matchesLotPlan(feature, lot, plan){
      try{
        const meta = parseParcelMeta(feature?.attributes||{});
        const lotN = normalizeLotPlanVal(lot);
        const planN = normalizePlanCode(plan);
        const lpField = normalizePlanCode(meta.lotplan||"");
        if(lotN && planN && lpField){
          if(lpField.includes(lotN) && lpField.includes(planN)) return true;
          const compact = `${lotN}${planN}`;
          if(lpField === compact || lpField === `${lotN}/${planN}`) return true;
        }
        if(lotN && planN){
          if(normalizeLotPlanVal(meta.lot)===lotN && normalizePlanCode(meta.plan)===planN) return true;
        }
      }catch{}
      return false;
    }
    function matchesPlanOnly(feature, plan){
      try{
        const planN = normalizePlanCode(plan);
        if(!planN) return false;
        const meta = parseParcelMeta(feature?.attributes||{});
        const planField = normalizePlanCode(meta.plan);
        const lpField = normalizePlanCode(meta.lotplan||"");
        return planField===planN || (lpField && lpField.includes(planN));
      }catch{ return false; }
    }
    function scoreLotPlan(feature, lot, plan){
      try{
        const meta = parseParcelMeta(feature?.attributes||{});
        const lotN = normalizeLotPlanVal(lot);
        const planN = normalizePlanCode(plan);
        const lpField = normalizePlanCode(meta.lotplan||"");
        const lotField = normalizeLotPlanVal(meta.lot);
        const planField = normalizePlanCode(meta.plan);

        const planMatch = planN
          ? (planField===planN || (lpField && lpField.includes(planN)))
          : true;
        const lotMatch = lotN
          ? (lotField===lotN || (lpField && lpField.includes(lotN)))
          : true;

        // If either provided part doesn't match, discard this candidate
        if(!planMatch || !lotMatch) return 0;

        let score = 0;
        if(lotN && lotField===lotN) score += 3;
        if(planN && planField===planN) score += 3;
        if(lotN && planN && lpField){
          const compact = `${lotN}${planN}`;
          if(lpField === compact || lpField === `${lotN}/${planN}`) score += 5;
          if(lpField.includes(lotN) && lpField.includes(planN)) score += 2;
        }
        if(planN && lpField && lpField.startsWith(planN)) score += 1;
        return score;
      }catch{ return 0; }
    }
    function isExactLotPlan(feature, lot, plan){
      try{
        const meta = parseParcelMeta(feature?.attributes||{});
        const lotN = normalizeLotPlanVal(lot);
        const planN = normalizePlanCode(plan);
        const lpField = normalizePlanCode(meta.lotplan||"");
        if(!lotN || !planN) return false;
        if(lpField === `${lotN}/${planN}` || lpField === `${lotN}${planN}`) return true;
        if(normalizeLotPlanVal(meta.lot)===lotN && normalizePlanCode(meta.plan)===planN) return true;
        return false;
      }catch{ return false; }
    }

    function smartJoin(parts){ return parts.filter(Boolean).join(" ").replace(/\s+/g," ").trim(); }
    const _get = (o, ks) => { for (const k of ks) if (k in o && String(o[k] ?? "").trim()) return String(o[k]).trim(); return null; };

    function parseCouncil(attrs){
      if(!attrs) return null;
      const first=(...keys)=>{ for(const k of keys){ if(k in attrs){ const v=String(attrs[k]??"").trim(); if(v) return v; } } return null; };
      return first("COUNCIL","COUNCIL_NAME","LGA","LGA_NAME","LOCAL_GOVERNMENT_AREA","AUTHORITY","ADMIN_BODY") || "Moreton Bay Regional Council";
    }

    /* ===== Address helpers ===== */
    const ADDR_DEBUG = false;

    const FULL_ADDR_FIELDS = [
      "FULL_ADDRESS","ADDRESS_FULL","GNAF_FULL_ADDRESS","GNAF_ADDRESS",
      "SITE_ADDRESS","PROPERTY_ADDRESS","PROP_ADDRESS","PRIMARY_ADDRESS",
      "ADDR_FULL","ADDR_LABEL","ADDRESS","STREET_ADDRESS","POSTAL_ADDRESS",
      "FULLADDR","FULL_ADD","FULL_ADDRE","SITE_ADDR","SITE_ADD","PROP_ADD",
      "PROPERTY_ADDR","PROPERTY_ADD","ADDRESS1","ADDRESS_1","ADDR1"
    ];

    const PART_FIELDS = {
      unit:  ["UNIT_NO","UNIT_NUMBER","UNIT","APARTMENT","FLAT","SUITE","SUB_UNIT","APT","FLAT_NO","UNITNO","UNITNUM"],
      numP:  ["HOUSE_PREFIX","NUMBER_PREFIX","ADDR_NUM_PREFIX","NUMBER_PRE","NO_PRE","HSE_PRE"],
      num:   ["HOUSE_NO","HOUSE_NUMBER","STREET_NO","STREET_NUMBER","PRIMARY_NO","PROPERTY_NO","NUMBER","HSE_NO","HSE_NUM","ADDR_NO"],
      numS:  ["HOUSE_SUFFIX","NUMBER_SUFFIX","ADDR_NUM_SUFFIX","NUMBER_SUF","NO_SUF","HSE_SUF"],
      stNm:  ["STREET_NAME","ST_NAME","ROAD_NAME","RD_NAME","ADD_STREET_NAME","STREET","ST_NAM","RD_NAM"],
      stTp:  ["STREET_TYPE","ST_TYPE","ROAD_TYPE","RD_TYPE","ADDR_TYPE","ST_TYP","RD_TYP"],
      stSf:  ["STREET_SUFFIX","ST_SUFFIX","ROAD_SUFFIX","RD_SUFFIX","ST_SUF","RD_SUF"],
      suburb:["SUBURB","SUBURB_NAME","LOCALITY","LOCALITY_NAME","TOWN","CITY","SUB_NAME","LOCALITY_N"],
      state: ["STATE","STATE_ABBR","STATE_CODE"],
      post:  ["POSTCODE","POST_CODE","ZIP","PSTCODE","PST_CD"]
    };

    const LOTPLAN_FIELDS = [
      "LOT_PLAN","LOT_PLAN_NO","LOTPLAN","LOTPLAN_NO","LOTPLAN_TXT","LOT_PLAN_TXT","LOT_PLAN_TEXT","LOTPLAN_TEXT"
    ];

    function _pick(attrs, keys){
      for(const k of keys){
        if(k in attrs){
          const v = String(attrs[k] ?? "").trim();
          if(v && v.toUpperCase()!=="NULL") return v;
        }
      }
      return null;
    }
    const _smartJoin = smartJoin;

    function buildAddressFromParts(attrs){
      const unit=_pick(attrs,PART_FIELDS.unit);
      const numP=_pick(attrs,PART_FIELDS.numP);
      const num =_pick(attrs,PART_FIELDS.num);
      const numS=_pick(attrs,PART_FIELDS.numS);
      const stNm=_pick(attrs,PART_FIELDS.stNm);
      const stTp=_pick(attrs,PART_FIELDS.stTp);
      const stSf=_pick(attrs,PART_FIELDS.stSf);
      const suburb=_pick(attrs,PART_FIELDS.suburb);
      const state=_pick(attrs,PART_FIELDS.state) || "QLD";
      const post =_pick(attrs,PART_FIELDS.post);

      const line1=_smartJoin([ unit ? (unit+"/") : null, _smartJoin([numP,num,numS]), _smartJoin([stNm,stTp,stSf]) ]);
      const line2=_smartJoin([ suburb, state, post ]);
      return _smartJoin([line1,line2]) || null;
    }

    function parseAddress(attrs){
      if(!attrs) return null;
      for(const f of FULL_ADDR_FIELDS){
        const v = attrs[f];
        if(v!=null){
          const s = String(v).trim();
          if(s && s.toUpperCase()!=="NULL") return s;
        }
      }
      for(const f of LOTPLAN_FIELDS){
        const s = String(attrs[f] ?? "").trim();
        if(/\d{1,5}\s+[A-Za-z].*\d{4}\b/.test(s)) return s;
      }
      const built = buildAddressFromParts(attrs);
      if(built) return built;
      for(const k in attrs){
        const v = String(attrs[k]??"").trim();
        if(!v) continue;
        const m=v.match(/\b\d{1,5}\s+[A-Za-z][A-Za-z\s.'-]+(?:\b(St|Street|Rd|Road|Ave|Avenue|Dr|Drive|Cres|Court|Ct|Lane|Ln|Terrace|Ter|Way|Pde|Parade)\b)[^,;]*?(?:,\s*[A-Za-z][A-Za-z\s.'-]+)?(?:\s+(?:QLD|Queensland))?\s*\d{4}\b/i);
        if(m) return m[0].replace(/\s+/g," ").trim();
      }
      return null;
    }

    function ensureSuburbInAddress(addr, attrs){
      if(!addr) return addr;
      const _p = (obj, keys)=>{
        for(const k of keys){
          if(k in obj){
            const v=String(obj[k]??"").trim();
            if(v && v.toUpperCase()!=="NULL") return v;
          }
        }
        return null;
      };
      const suburb=_p(attrs||{}, PART_FIELDS.suburb);
      const state=_p(attrs||{}, PART_FIELDS.state) || "QLD";
      const post =_p(attrs||{}, PART_FIELDS.post);

      if(!suburb) return addr;

      const norm = s => String(s||"").toUpperCase().replace(/[,\s]+/g," ").trim();
      if (norm(addr).includes(norm(suburb))) return addr;

      const rxTail = new RegExp(String.raw`(?:,\s*)?(?:QLD|Queensland)\s*${post?String.raw`\b${post}\b`:''}\s*$`,"i");
      const tailWanted = `${suburb} ${state}${post?` ${post}`:""}`;

      if (rxTail.test(addr)){
        return addr.replace(rxTail, `, ${tailWanted}`);
      }
      return `${addr.replace(/\s+,/g, ",")}, ${tailWanted}`;
    }

    function looksLikeAddressLayer(node){
      const hay = ((node.title||"")+" "+nodePath(node)).toLowerCase();
      return /\b(gnaf|address|addr|property\s*address|site\s*address|street\s*address|address\s*points|locality|suburb|road\s*centerline|road\s*centreline)\b/.test(hay);
    }

    async function scanAddressLayers(lotGeom){
      const nodes = flattenFeatureNodes().filter(n=>{
        try{ return looksLikeAddressLayer(n); }catch{return false;}
      });
      const centroid = centroidOf(lotGeom);
      const candidates = [];

      for(const n of nodes){
        try{
          await n.load();
          const outFields = ["*"];

          const r1 = await n.queryFeatures({
            geometry: lotGeom, spatialRelationship: "intersects",
            returnGeometry: false, outFields, maxRecordCountFactor: 3
          });
          (r1.features||[]).forEach(f=>{
            const addr = parseAddress(f.attributes);
            if(addr) candidates.push({addr, score: 3, layer:n});
          });

          if(centroid){
            const r2 = await n.queryFeatures({
              geometry: centroid, distance: 40, units: "meters",
              spatialRelationship: "intersects", returnGeometry: false,
              outFields, maxRecordCountFactor: 3
            });
            (r2.features||[]).forEach(f=>{
              const addr = parseAddress(f.attributes);
              if(addr) candidates.push({addr, score: 2, layer:n});
            });
          }
        }catch(e){
          if(ADDR_DEBUG) console.warn("Address layer failed:", n.title, e);
        }
      }

      candidates.sort((a,b)=>
        (b.score-a.score) ||
        ((/\d/.test(b.addr)?1:0)-(/\d/.test(a.addr)?1:0)) ||
        (b.addr.length-a.addr.length)
      );
      if(ADDR_DEBUG) console.log("Address candidates:", candidates);
      return candidates.length ? candidates[0].addr : null;
    }

    async function resolveBestAddress(geom, parcelFeature){
      let addr = parcelFeature ? parseAddress(parcelFeature.attributes||{}) : null;
      const weak = !addr || addr.trim().length<=4 || /^[A-Z]{2,3}$/.test(addr.trim());

      if(weak){
        try{
          const fromLayers = await scanAddressLayers(geom);
          if(fromLayers) addr = fromLayers;
        }catch(e){
          if(ADDR_DEBUG) console.warn("scanAddressLayers error:", e);
        }
      }

      if(!addr || addr.trim().length<=4){
        try{
          const cen = centroidOf(geom);
          if(cen){
            const res = await locator.locationToAddress(GEOCODER_URL,{location:cen});
            addr = res?.address || res?.attributes?.Match_addr || res?.attributes?.LongLabel || res?.attributes?.Address || addr;
          }
        }catch(e){
          if(ADDR_DEBUG) console.warn("reverse geocode failed:", e);
        }
      }

      addr = ensureSuburbInAddress(addr, parcelFeature?.attributes || {});
      return addr || "Address unavailable";
    }

    function flattenFeatureNodes(){ const out=[]; walkAny(view.map,(n)=>{ if(n && (n.type==="feature"||n.type==="sublayer") && (typeof n.queryFeatures==="function" || typeof n.queryFeatureCount==="function")) out.push(n); }); return out; }
    const PARCEL_FIELD_RX=/\b(LOT(?:_?PLAN)?|LOTNO|LOT_NO|LOTNUMBER|LOT_NUM|LOTNUM|PLAN|PLAN_NO|PLANNO|LOT_PLAN|LOTPLAN|LOT_PLAN_TXT|LOTPLAN_TXT|PARCEL|PARCEL_ID|PROP(?:ERTY)?_?ID?)\b/i;
    function hasParcelFields(node){
      try{
        const flds=node.fields||[];
        return flds.some(f=>PARCEL_FIELD_RX.test(String(f.name||"")));
      }catch{return false;}
    }
    const looksLikeParcelLayer=node=>{
      const hay=((node.title||"")+" "+nodePath(node)+" "+(node.url||"")).toLowerCase();
      return /(cadast|parcel|dcdb|lot|property)/i.test(hay);
    };

    async function findParcelAtPoint(point){
      const all=flattenFeatureNodes();
      const pref=[],rest=[];
      for(const n of all){
        try{
          await n.load();
          if(n.geometryType!=="polygon") continue;
          (looksLikeParcelLayer(n)||hasParcelFields(n)?pref:rest).push(n);
        }catch{}
      }
      const layers=[...pref,...rest];
      const collect=async(opts)=>{ const out=[]; for(const L of layers){ try{ const r=await L.queryFeatures({...opts,returnGeometry:true,outFields:["*"],maxRecordCountFactor:2}); (r.features||[]).forEach(f=>out.push({layer:L,feature:f})); }catch{} } return out; };
      let cand=await collect({geometry:point,spatialRelationship:"intersects"});
      let contains=cand.filter(({feature})=>{ try{ return geometryEngine.contains(feature.geometry,point); }catch{ return false; } });
      if(contains.length){
        let best=contains[0], bestD=Infinity;
        for(const c of contains){ let d=Infinity; try{ const cen=centroidOf(c.feature.geometry); d=geometryEngine.distance(point,cen)||Infinity; }catch{} if(d<bestD){ best=c; bestD=d; } }
        return best.feature;
      }
      cand=await collect({geometry:point,distance:1.5,units:"meters",spatialRelationship:"intersects"});
      if(cand.length){
        let best=cand[0], bestD=Infinity;
        for(const c of cand){ let d=Infinity; try{ const near=geometryEngine.nearestCoordinate(c.feature.geometry,point); d=near?.distance??Infinity; }catch{} if(d<bestD){ best=c; bestD=d; } }
        return best.feature;
      }
      return null;
    }

    let lastParcelInfo={feature:null,lotText:"--",areaText:"-- "+M2,classText:"--",addressText:"--",councilText:"Moreton Bay Regional Council"};

    function updateSummaryPanel(){
      setText("sumLot", lastParcelInfo.lotText || "--");
      setText("sumArea", lastParcelInfo.areaText || ("-- "+M2));
      setText("sumClass", lastParcelInfo.classText || "--");
      setText("sumAddress", lastParcelInfo.addressText || "--");
      setText("sumCouncil", lastParcelInfo.councilText || "Moreton Bay Regional Council");
    }

    function outlineSelection(geom){
      selLayer.removeAll();
      if(!geom) return;
      selLayer.add(new Graphic({geometry:geom,symbol:{type:"simple-fill",color:[0,0,0,0],outline:{color:"#a70b13",width:2}}}));
    }
    function parcelInfoFromFeature(feat){
      const attrs=feat?.attributes||{};
      const meta=parseParcelMeta(attrs);
      const lotplan=meta.lotplan || ((meta.lot||meta.plan)?[meta.lot,meta.plan].filter(Boolean).join("/"):"--");
      const area=getLotAreaSqm(attrs) ?? geomAreaSqmSafe(feat.geometry) ?? null;
      const cls=(area!=null && area<450)?"Small lot":"Standard lot";
      let address=parseAddress(attrs) || "--";
      if(address && address!=="--") address = ensureSuburbInAddress(address, attrs);
      const council=parseCouncil(attrs) || "Moreton Bay Regional Council";
      return { lotText:lotplan||"--", areaText:area!=null?(Math.round(area).toLocaleString()+" "+M2):("-- "+M2), classText:cls, addressText:address, councilText:council };
    }
    function updateBadgesFromFeature(feat){
      const info=parcelInfoFromFeature(feat);
      if($("lotBadge")) $("lotBadge").textContent="Lot: "+info.lotText;
      if($("areaBadge")) $("areaBadge").textContent="Area: "+info.areaText;
      if($("classBadge")) $("classBadge").textContent="Class: "+info.classText;
      lastParcelInfo={feature:feat,...info};
      updateSummaryPanel();
    }

    const bufferedAOIFor=(node,geom)=>{ try{ const gt=(node.geometryType||"").toLowerCase(); if(gt==="point"||gt==="multipoint"||gt==="polyline") return geometryEngine.buffer(geom,TOUCH_BUFFER_M,"meters"); }catch{} return geom; };
    async function countFeatures(node,geom){
      if(!node) return 0;
      const hasNativeQueries=(typeof node.queryFeatureCount==="function") || (typeof node.queryFeatures==="function");
      const tryCount=async target=>{
        if(!target) return 0;
        const g=bufferedAOIFor(target,geom);
        try{
          if(typeof target.queryFeatureCount==="function"){
            const c=await target.queryFeatureCount({geometry:g,spatialRelationship:"intersects"});
            const num=Number(c)||0;
            if(num) return num;
          }
        }catch{}
        try{
          if(typeof target.queryFeatures==="function"){
            const q=await target.queryFeatures({geometry:g,spatialRelationship:"intersects",returnGeometry:false,outFields:["*"],num:1});
            if(q.features?.length) return q.features.length;
          }
        }catch{}
        return 0;
      };
      let cnt=await tryCount(node);
      if(cnt>0 || hasNativeQueries) return cnt;
      const fl=await featureLayerFor(node);
      if(!fl) return cnt;
      return await tryCount(fl);
    }
    async function hideUnusedOverlaysFor(geom){
      const nodes=[]; walkAny(view.map,(n)=>{ if(n && (n.type==="feature"||n.type==="sublayer") && (typeof n.queryFeatures==="function" || typeof n.queryFeatureCount==="function")) nodes.push(n); });
      for(const n of nodes){
        const t=n.title||n.id||"", id=n.id||"", tg=n.portalItem?.tags||[], p=nodePath(n);
        if(isDNT(t,id,tg)) continue;
        if(isUtility(t,id,tg,p)) continue;
        if(isWaterOrSewer(p)) continue;
        try{ await n.load(); const cnt=await countFeatures(n,geom); if("listMode"in n) n.listMode=cnt>0?"show":"hide"; }catch{}
      }
      try{ layerList.refresh(); }catch{}
    }

    function underDNTChain(node){
      let cur=node;
      while(cur){
        const t=cur.title||"", id=cur.id||"", tg=cur.portalItem?.tags||[];
        if(isDNT(t,id,tg)) return true;
        cur=cur.parent;
      }
      return false;
    }

    async function updateSideOverlaySummary(geom){
      const ul = $("sumOverlays");
      if (!ul) return;
      ul.innerHTML = "<li><i>Scanning…</i></li>";

      const items = [];
      const nodes = flattenFeatureNodes().filter(n => !underDNTChain(n));

      for (const n of nodes){
        try{
          const t = n.title || "", id = n.id || "", tg = n.portalItem?.tags || [];
          const p = nodePath(n);
          if (isUtility(t,id,tg,p) || isWaterOrSewer(p)) continue;

          await n.load();

          const cnt = await countFeatures(n, geom);
          if (cnt <= 0) continue;

          const { items: keys } = await legendFromRendererUsingFeatures(n, geom);
          const keyHTML = keys.length
            ? `<div class="leg" style="margin-top:4px">${keys.map(k =>
                `<div class="row">${k.swatchHTML}${htmlEsc(k.label)}</div>`
              ).join("")}</div>`
            : "";

          const title = htmlEsc(t || "Layer");
          items.push(
            `<li>
               <div class="ov-title">${title} <span style="color:#777">(${cnt})</span></div>
               ${keyHTML}
             </li>`
          );
        }catch{}
      }

      ul.innerHTML = items.length
        ? items.join("")
        : "<li><i>No overlays intersect this parcel.</i></li>";
    }

    async function focusOnParcelFeature(feat,{shouldZoom=false}={}){
      if(!feat || !feat.geometry) return;
      const geom = normalizeToWebMercator(projectToViewSR(feat.geometry));
      feat.geometry = geom;
      updateBadgesFromFeature(feat);
      selLayer.removeAll();
      if(geom.type==="point" || geom.type==="multipoint"){
        selLayer.add(new Graphic({geometry:geom,symbol:{type:"simple-marker",style:"circle",size:10,color:[167,11,19,0.2],outline:{color:"#a70b13",width:2}}}));
      }else{
        outlineSelection(geom);
      }
      await hideUnusedOverlaysFor(geom);
      try{
        const addr=await resolveBestAddress(geom, feat);
        lastParcelInfo.addressText=addr||lastParcelInfo.addressText||"Address unavailable";
        updateSummaryPanel();
      }catch{}
      updateSideOverlaySummary(geom);
      if(shouldZoom){
        try{
          if(geom.type==="point" || geom.type==="multipoint"){
            await view.goTo({target:geom, zoom:18});
          }else{
            const ext = geom.extent || framedExtent(geom);
            if(ext){
              await view.goTo({target:ext.expand(1.2), animate:true});
            }else if(geom.centroid){
              await view.goTo({target:geom.centroid, zoom:18});
            }else{
              await view.goTo({target:geom, zoom:18});
            }
          }
        }catch(err){
          console.warn("goTo failed", err);
        }
      }
    }

    view.on("click", async ev=>{
      try{
        showLoading(true);
        const parcel=await findParcelAtPoint(ev.mapPoint);
        if(!parcel){ selLayer.removeAll(); return; }
        await focusOnParcelFeature(parcel,{shouldZoom:true});
      } finally { showLoading(false); }
    });

    /* ---------------- Legend helpers ---------------- */
    async function swatchHTML(symbol){
      try{
        const el=await symbolUtils.renderPreviewHTML(symbol,{size:[SWATCH_PX-2,SWATCH_PX-2]});
        if(el.tagName?.toLowerCase()==="canvas"){ return `<span class="swbox"><img alt="" src="${el.toDataURL("image/png")}"></span>`; }
        try{ el.setAttribute("width","100%"); el.setAttribute("height","100%"); }catch{}
        return `<span class="swbox">${el.outerHTML}</span>`;
      }catch{ return `<span class="swbox" style="background:#cfcfcf"></span>`; }
    }
    const guessLabelFromAttrs = attrs => {
      if (!attrs) return null;
      const patt = [/zone.*(name|type|desc|label|category|code)?/i, /(planning|scheme).*zone/i, /(zone|category|type|class|desc|label)/i];
      for (const r of patt) {
        const k = Object.keys(attrs).find(x => r.test(x));
        if (k) {
          const v = String(attrs[k] ?? "").trim();
          if (v) return v;
        }
      }
      return null;
    };
    function getUVInfo(renderer,attrs){
      if(!renderer||!attrs) return null;
      const fields=[renderer.field,renderer.field2,renderer.field3].filter(Boolean);
      const delim=renderer.fieldDelimiter??", ";
      if(!fields.length) return null;
      const parts=fields.map(f=>attrs[f]); const key=parts.join(delim);
      const infos=renderer.uniqueValueInfos||[];
      let info=infos.find(u=>String(u.value)===String(key));
      if(!info) info=infos.find(u=>Array.isArray(u.values)&&u.values.some(v=>String(v)===String(key)));
      if(!info && fields.length===1){
        info=infos.find(u=>String(u.value)===String(attrs[fields[0]]))||
              infos.find(u=>Array.isArray(u.values)&&u.values.some(v=>String(v)===String(attrs[fields[0]])));
      }
      return info||null;
    }
    const ZONE_KEYS=["ZONE_CODE","ZONE","ZONE_NAME","ZONING","ZONE_LABEL","ZONE_DESC","ZONE_TYPE","ZONE_CATEGORY","PLANNING_ZONE"];
    function pickZoneLabel(attrs){
      if(!attrs) return null;
      const code=String(attrs.ZONE_CODE ?? attrs.ZONE ?? "").trim();
      const name=String(attrs.ZONE_NAME ?? attrs.ZONING ?? "").trim();
      if(code && name) return `${code} – ${name}`;
      for(const k of ZONE_KEYS){ const v=attrs[k]; if(v!=null && String(v).trim()) return String(v).trim(); }
      return null;
    }
    async function legendFromRendererUsingFeatures(layerNode,lotGeom){
      const gt=(layerNode.geometryType||"").toLowerCase();
      const isZone=isZoning(layerNode.title||"",nodePath(layerNode));
      const g=(gt==="point"||gt==="multipoint"||gt==="polyline") ? geometryEngine.buffer(lotGeom,TOUCH_BUFFER_M,"meters") : lotGeom;

      const queryOpts={geometry:g,spatialRelationship:"intersects",returnGeometry:true,outFields:["*"],maxRecordCountFactor:6};
      const fetchFeatures=async target=>{
        if(typeof target?.queryFeatures!=="function") return [];
        try{
          const q=await target.queryFeatures(queryOpts);
          return q.features||[];
        }catch{
          return [];
        }
      };
      let legendSource=layerNode;
      let feats=await fetchFeatures(legendSource);
      if(!feats.length){
        const fl=await featureLayerFor(layerNode);
        if(fl){
          legendSource=fl;
          feats=await fetchFeatures(fl);
        }
      }
      if(!feats.length) return {items:[]};

      const itemMap=new Map();
      for(const f of feats){
        const gph=new Graphic({geometry:f.geometry,attributes:f.attributes,layer:legendSource});
        let sym=null;
        try{ sym=await symbolUtils.getDisplayedSymbol(gph,view); }catch{}
        if(!sym){
          const r=legendSource.renderer || layerNode.renderer; sym = r?.symbol || r?.defaultSymbol || f.symbol || null;
        }
        if(!sym) continue;

        let label=isZone?pickZoneLabel(f.attributes):null;
        if(!label){
          const r=legendSource.renderer || layerNode.renderer;
          if(r?.type==="unique-value"){
            const info=getUVInfo(r,f.attributes);
            if(info) label=info.label ?? String(info.value ?? (info.values||[]).join(", "));
          }else if(r?.type==="class-breaks" && r.field){
            const v=Number(f.attributes?.[r.field]);
            if(!Number.isNaN(v)){
              const info=(r.classBreakInfos||[]).find(b=>{
                const min=(b.minValue==null?-Infinity:b.minValue), max=(b.maxValue==null?Infinity:b.maxValue);
                return v>=min && v<=max;
              });
              label=info?.label ?? (info ? `${info.minValue ?? ""} – ${info.maxValue ?? ""}` : null);
            }
          }
          if(!label) label=r?.label || layerNode.title || guessLabelFromAttrs(f.attributes) || "Class";
        }
        const sw=await swatchHTML(sym);
        if(!itemMap.has(label)) itemMap.set(label,{label,swatchHTML:sw});
      }
      return {items:[...itemMap.values()]};
    }

    /* ---------------- Report build ---------------- */
    function saveVisibility(root){ const map=new Map(); walkAny(root,(n)=>{ if("visible"in n){ map.set(nodePath(n),{vis:!!n.visible,op:n.opacity,min:n.minScale,max:n.maxScale,blend:n.blendMode}); } }); return map; }
    function restoreVisibility(root,snap){ walkAny(root,(n)=>{ if("visible"in n){ const k=nodePath(n); if(snap.has(k)){ const s=snap.get(k); try{n.visible=s.vis;}catch{} if("opacity"in n && s.op!==undefined){ try{n.opacity=s.op;}catch{} } if("blendMode"in n && s.blend!==undefined){ try{n.blendMode=s.blend;}catch{} } try{n.minScale=s.min;n.maxScale=s.max;}catch{} } } }); }
    async function awaitRenderFor(nodes){
      const owningLayer=node=>{let c=node; while(c && c.type==="sublayer") c=c.parent; return c && c.type!=="sublayer" ? c : null;};
      const layers=[...new Set(nodes.map(n=>owningLayer(n)).filter(Boolean))];
      const views=[]; for(const L of layers){ try{views.push(await view.whenLayerView(L));}catch{} }
      if(views.length){ try{await reactiveUtils.whenOnce(()=>views.every(v=>v.updating===false));}catch{} }
      await waitViewIdle(240);
    }
    async function countFeaturesSum(nodes,geom){ let t=0; for(const n of nodes){ t+=await countFeatures(n,geom); } return t; }

    async function screenshotFor(nodes,title,lotGeom,legendOnLot=false,{forceAllVisible=false}={}){
      if(!nodes?.length || !lotGeom) return null;

      const present=forceAllVisible ? [...nodes] : [];
      if(!forceAllVisible){ for(const n of nodes){ if(await countFeatures(n,lotGeom)>0) present.push(n); } }
      if(!present.length && !forceAllVisible) return null;

      const visSnap=saveVisibility(view.map), scaleSnap=new Map(), opSnap=new Map(), blendSnap=new Map();

      try{
        return await withViewOnGeom(lotGeom, async ()=>{
          walkAny(view.map,(n)=>{
            if(!("visible"in n)) return;
            if(underDNTChain(n)) return;
            try{ n.visible=false; }catch{}
          });
          try{ selLayer.visible=true; }catch{}

          const targets = present.length ? present : nodes;

          const ancestors=node=>{const out=[]; let p=node?.parent; while(p){out.push(p); p=p.parent;} return out;};
          for(const n of targets){
            for(const a of [n,...ancestors(n)]){
              if(!("visible"in a)) continue;
              try{ a.visible=true; }catch{}
              if("minScale"in a || "maxScale"in a){
                if(!scaleSnap.has(a)) scaleSnap.set(a,{min:a.minScale,max:a.maxScale});
                try{ a.minScale=0; a.maxScale=0; }catch{}
              }
            }
            if("blendMode"in n){ if(!blendSnap.has(n)) blendSnap.set(n,n.blendMode); }
            if("opacity"in n){ if(!opSnap.has(n))    opSnap.set(n,n.opacity); }
          }
          await awaitRenderFor(targets);

          const shot=await view.takeScreenshot({format:"png",quality:95,width:SHOT_SIZE.width,height:SHOT_SIZE.height});

          let legendGeom=lotGeom;
          if(!legendOnLot){ try{ const onScr=geometryEngine.intersect(lotGeom,view.extent); if(onScr) legendGeom=onScr; }catch{} }

          const legendParts=[];
          for(const n of targets){
            if(underDNTChain(n)) continue;
            if(typeof n.queryFeatures!=="function" && typeof n.queryFeatureCount!=="function") continue;
            const {items}=await legendFromRendererUsingFeatures(n,legendGeom);
            if(items.length){
              const inner=items.map(i=>`<div class="row">${i.swatchHTML}${i.label.replace(/&/g,"&amp;")}</div>`).join("");
              legendParts.push(`<div style="margin-bottom:6px"><b>${(n.title||"Layer").replace(/&/g,"&amp;")}</b><div class="leg" style="margin-top:4px">${inner}</div></div>`);
            }
          }

          const count=await countFeaturesSum(nodes,lotGeom);
          return {title,id:"rpt-"+slug(title),dataUrl:shot.dataUrl,legendHTML:legendParts.join(""),count};
        });
      } finally {
        for(const [n,op] of opSnap){ try{n.opacity=op;}catch{} }
        for(const [n,bl] of blendSnap){ try{n.blendMode=bl;}catch{} }
        for(const [n,sc] of scaleSnap){ try{n.minScale=sc.min;n.maxScale=sc.max;}catch{} }
        restoreVisibility(view.map,visSnap);
      }
    }

    function setRpt(msg,pct,doneStepId){
      const bar=$("rptBar"), m=$("rptMsg");
      if(m && msg!=null) m.textContent=msg;
      if(bar && pct!=null) bar.style.width=Math.max(0,Math.min(100,pct))+"%";
      if(doneStepId){ const step=$(doneStepId); if(step) step.classList.add("rptDone"); }
    }

    async function addMandatorySection(shots, title, collectorFn, geom, baseShot, emptyNote){
      try{
        const nodes = collectorFn();
        if(nodes.length){
          const s = await screenshotFor(nodes, title, geom, false, {forceAllVisible:true});
          if(!s){ shots.push({title,id:"rpt-"+slug(title),dataUrl:baseShot.dataUrl,legendHTML:"",count:0,note:emptyNote}); }
          else { if((s.count||0)===0) s.note=emptyNote; shots.push(s); }
        }else{
          shots.push({title,id:"rpt-"+slug(title),dataUrl:baseShot.dataUrl,legendHTML:"",count:0,note:emptyNote});
        }
      }catch(err){
        console.warn("Mandatory section failed:", title, err);
        shots.push({title,id:"rpt-"+slug(title),dataUrl:baseShot.dataUrl,legendHTML:"",count:0,note:emptyNote+" (layer unavailable)"});
      }
    }

    let lastReportHTML=null, lastReportTitle="Property Report";
    document.getElementById("btnPrintReport").addEventListener("click", async ()=>{
      const actions=$("rptActions");
      if(actions) actions.style.display="none";
      document.getElementById("rptOverlay").style.display="grid";
      try{
        const result = await buildAndOpenReport();
        if(result && result.html){
          lastReportHTML = result.html;
          lastReportTitle = result.title || "Property Report";
          setRpt("Report ready. Choose an option below.", 100, "rptS4");
          const msg=$("rptReadyMsg"); if(msg) msg.textContent="Report ready. Choose an option below.";
          if(actions) actions.style.display="flex";
        }else{
          document.getElementById("rptOverlay").style.display="none";
        }
      } catch(e){
        console.error(e);
        alert("Could not create report.");
        document.getElementById("rptOverlay").style.display="none";
      }
    });

    async function buildAndOpenReport(){
      try{
        showLoading(true);
        setRpt("Locating parcel…", 12);
        let geom=null, lotText="--", areaText="-- "+M2, classText="--", addressText="--", councilText="Moreton Bay Regional Council";
        if(lastParcelInfo.feature){
          geom=lastParcelInfo.feature.geometry; ({lotText,areaText,classText,addressText,councilText}=lastParcelInfo);
        }else{
          const probe=await findParcelAtPoint(view.center);
          if(probe){ const info=parcelInfoFromFeature(probe); geom=probe.geometry; ({lotText,areaText,classText,addressText,councilText}=info); lastParcelInfo={feature:probe,...info}; }
        }
        setRpt("Parcel located", 18, "rptS1");

        if(geom){
          setRpt("Resolving address…", 25);
          try{ addressText=await resolveBestAddress(geom,lastParcelInfo.feature); }catch{}
          setRpt("Address resolved", 35, "rptS2");
          lastParcelInfo.addressText = addressText || lastParcelInfo.addressText;
        }

        setRpt("Rendering base map…", 42);
        const baseShot = geom
          ? await withViewOnGeom(geom, async()=>{ try{selLayer.visible=true;}catch{}; await waitViewIdle(200); return await view.takeScreenshot({format:"png",quality:95,width:SHOT_SIZE.width,height:SHOT_SIZE.height}); })
          : await view.takeScreenshot({format:"png",quality:95,width:SHOT_SIZE.width,height:SHOT_SIZE.height});

        setRpt("Collecting overlays…", 55);
        const cats = geom ? await (async()=>{
          const out={zoning:[],utilities:[],acid:[],transport:[],air:[],noise:[],bushfire:[],others:[]};
          const arr=[]; walkAny(view.map,(n,underDNT)=>{ const canQuery=(typeof n?.queryFeatures==="function" || typeof n?.queryFeatureCount==="function"); const canProxy=typeof n?.createFeatureLayer==="function"; if(n && (n.type==="feature"||n.type==="sublayer") && (canQuery||canProxy) && !underDNT) arr.push(n); });
          for(const n of arr){
            try{
              await n.load();
              const t=n.title||"", p=nodePath(n);
              const zoneMatch=isZoning(t,p);
              const cnt=await countFeatures(n,geom); if(!cnt && !zoneMatch) continue;
              if(zoneMatch) out.zoning.push(n);
              else if(isUtility(t,n.id,n.portalItem?.tags||[],p) || isWaterOrSewer(p)) out.utilities.push(n);
              else if(isAcid(t,p)) out.acid.push(n);
              else if(isTransport(t,p)) out.transport.push(n);
              else if(isAir(t,p)) out.air.push(n);
              else if(isNoise(t,p)) out.noise.push(n);
              else if(isBushfire(t,p)) out.bushfire.push(n);
              else out.others.push(n);
            }catch{}
          }
          return out;
        })() : {zoning:[],utilities:[],acid:[],transport:[],air:[],noise:[],others:[]};

        const shots=[];
        const tasks=[
          ["Zoning", async()=>{ if(cats.zoning.length){ const s=await screenshotFor(cats.zoning,"Zoning",geom,true,{forceAllVisible:true}); if(s) shots.push(s); }}],
          ["Bushfire", async()=>{ await addMandatorySection(shots,"Bushfire",()=>cats.bushfire,geom,baseShot,"No bushfire Lv"); }],
          ["Utilities", async()=>{ if(cats.utilities.length){ const s=await screenshotFor(cats.utilities,"Utilities",geom,false,{forceAllVisible:true}); if(s) shots.push(s); } }],
          ["Acid overlays", async()=>{ if(cats.acid.length){ const s=await screenshotFor(cats.acid,"Acid overlays",geom); if(s) shots.push(s); }}],
          ["Transport", async()=>{ if(cats.transport.length){ const s=await screenshotFor(cats.transport,"Transport",geom); if(s) shots.push(s); }}],
          ["Air quality", async()=>{ if(cats.air.length){ const s=await screenshotFor(cats.air,"Air quality",geom); if(s) shots.push(s); }}],
          ["Transport Noise Corridor", async()=>{ await addMandatorySection(shots,"Transport Noise Corridor",()=>cats.noise,geom,baseShot,"No noise Lv"); }],
          ["Other overlays", async()=>{
            for (const n of cats.others) {
              const t = n.title || "", p = nodePath(n);
              if (/(bush\s*fire|bushfire|noise)/i.test(t) || /(bush\s*fire|bushfire|noise)/i.test(p)) continue;
              const s = await screenshotFor([n], n.title || "Overlay", geom);
              if (s) shots.push(s);
            }
          }]
        ];
        for(let i=0;i<tasks.length;i++){
          const [name,fn]=tasks[i];
          setRpt(`Rendering ${name}…`, 55 + Math.round(((i+1)/tasks.length)*30));
          await fn();
        }
        setRpt("Overlays rendered", 87, "rptS3");

        setRpt("Composing document…", 93);
        const now=new Date();
        const fmt=d=> d.toLocaleString(undefined,{year:'numeric',month:'short',day:'2-digit',hour:'2-digit',minute:'2-digit'});
        const esc=htmlEsc;
        const logoSrc="./images/Flavour icon.png";

        /* ==== Dynamic report name bits (address → title/file name) ==== */
        var toFileSafe = function (s) {
          return String(s)
            .replace(/[<>:"/\\|?*\x00-\x1F]/g, "")
            .replace(/\s+/g, " ")
            .trim();
        };
        var baseName = (addressText && addressText !== "--")
          ? addressText
          : ((lotText && lotText !== "--") ? ("Lot " + lotText) : "Property");
        var reportDisplayTitle = baseName + " — Property Report";
        var reportFileTitle    = toFileSafe(reportDisplayTitle);

        const html=[];
        html.push("<!doctype html><meta charset='utf-8'><title>", esc(reportFileTitle), "</title>");
        html.push("<style>",
          ":root{--brand:#a70b13;--brand2:#7f0e15;--bg:#f6f7f9;--ink:#0b0d12;--border:#e1e3e6;--radius:14px;--shadow:0 6px 18px rgba(16,21,28,.08);--panel:#ffffff;--panel-2:#f8f9fb;--muted:#5b6470}",
          "body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:18px;color:var(--ink);background:var(--bg);line-height:1.4}",
          "a{color:var(--brand2)}",
          ".card{border:1px solid var(--border);border-radius:var(--radius);padding:14px;margin:10px 0;background:var(--panel);box-shadow:var(--shadow)}",
          ".brandbar{display:flex;align-items:center;gap:12px;padding:14px 16px;margin:-14px -14px 14px -14px;color:#fff;background:linear-gradient(90deg,var(--brand),var(--brand2));border-radius:var(--radius) var(--radius) 0 0;box-shadow:var(--shadow)}",
          ".brandbar img{width:28px;height:28px;border:1px solid #ddd;background:#fff;border-radius:6px}",
          ".brandbar h1{margin:0;font-size:18px;font-weight:800;letter-spacing:.2px}",
          ".brandbar .muted{margin-left:auto;opacity:.95;font-weight:600}",
          ".rpt-grid{display:grid;grid-template-columns:minmax(0,1fr) minmax(0,1.2fr);gap:16px}",
          ".propmap{grid-column:1 / -1}",
          ".propmap-grid{display:grid;grid-template-columns:minmax(0,1fr) minmax(0,1.6fr);gap:16px;align-items:start}",
          ".badge-pill{display:inline-block;border:1px solid var(--border);border-radius:999px;padding:3px 9px;margin:3px 6px 0 0;background:#fff;font-size:11px;font-weight:600;color:var(--ink)}",
          ".kv{margin-top:8px;font-size:14px;color:var(--ink)}.kv div{margin:4px 0}",
          "img.map{display:block;width:auto;max-width:100%;height:auto;border:1px solid #e6e8ec;border-radius:12px;box-shadow:0 6px 14px rgba(16,21,28,.08);background:#fff;margin:0}",
          ".section-title{margin:0 0 8px;font-size:16px;letter-spacing:.2px;color:var(--brand2)}",
          ".section-title:after{content:\"\";display:block;width:36px;height:3px;margin-top:6px;border-radius:999px;background:linear-gradient(90deg,var(--brand),var(--brand2))}",
          ".overlay-header{display:flex;flex-direction:column;align-items:flex-start;gap:6px;padding-bottom:8px;margin-bottom:10px;border-bottom:1px solid #edf0f3}",
          ".overlay-actions{display:flex;flex-wrap:wrap;gap:8px;justify-content:flex-start}",
          ".backbtn{display:inline-flex;align-items:center;gap:6px;border:1px solid rgba(167,11,19,.22);border-radius:999px;padding:5px 12px;font-size:11px;font-weight:700;color:var(--brand2);text-decoration:none;background:#fff;box-shadow:0 1px 0 rgba(16,21,28,.05)}.backbtn:hover{background:#fff0f1;border-color:var(--brand)}",
          ".sumlist{margin:6px 0 0 18px;padding:0}.sumlist li{margin:8px 0 12px}",
          ".sumlist li::marker{color:var(--brand2)}",
          ".note{margin-top:8px;font-size:13px;color:var(--brand);font-weight:700;background:#fff4f4;border:1px solid #f3c7c7;border-radius:10px;padding:6px 10px;display:inline-block}",
          ".leg{font-size:13px;line-height:1.4;margin-top:8px}.leg .row{display:flex;align-items:center;gap:8px;margin:2px 0}",
          ".leg .swbox{display:inline-flex;align-items:center;justify-content:center;width:16px;height:14px;padding:1px;border:1px solid #9aa0a6;border-radius:4px;overflow:hidden;background:#fff}",
          ".leg .swbox img,.leg .swbox svg,.leg .swbox canvas{width:100%;height:100%;display:block;object-fit:contain}",
          ".map-legend{display:grid;grid-template-columns:minmax(0,2fr) minmax(0,1fr);gap:14px;align-items:start}",
          ".map-legend .leg{margin-top:0;background:var(--panel-2);border:1px solid rgba(167,11,19,.18);border-radius:10px;padding:10px}",
          "@media (max-width: 900px){.map-legend{grid-template-columns:1fr}}",
          ".rpt-footer{margin-top:14px;padding-top:8px;border-top:1px dashed var(--border);font-size:12px;color:var(--muted)}",
          "@media print{*{-webkit-print-color-adjust:exact!important;print-color-adjust:exact!important}.card{page-break-inside:avoid}}",
          "</style>");
        html.push("<body>");
        html.push("<div class='card brandbar'><img src='",logoSrc,"' alt='Logo'><h1>", esc(reportDisplayTitle), "</h1><div class='muted'>",fmt(now),"</div></div>");

        html.push("<div class='rpt-grid'>");
          html.push("<div class='card propmap'>",
                      "<div class='propmap-grid'>",
                        "<div>",
                          "<h2 class='section-title'>Property</h2>",
                          "<div class='badge-pill'>Lot: ",esc(lotText),"</div>",
                          "<div class='badge-pill'>Area: ",esc(areaText),"</div>",
                          "<div class='badge-pill'>Class: ",esc(classText),"</div>",
                          "<div class='kv'>",
                            "<div><b>Address:</b> ",esc(addressText),"</div>",
                            "<div><b>Council:</b> ",esc(councilText),"</div>",
                          "</div>",
                          "<div id='summary' style='margin-top:14px'>",
                            "<h2 class='section-title' style='margin-top:0'>Summary</h2>");
                            if(shots.length){
                              html.push("<ul class='sumlist'>");
                              for(const s of shots){
                                const ct=(s.count!=null)?(" ("+s.count+" feature"+(s.count===1?"":"s")+")"):"";
                                html.push("<li><a class='sum-link' style='color:#7a0f16;font-weight:700;text-decoration:none' href='#",s.id,"'>",esc(s.title),"</a>",ct,(s.note?(" - "+esc(s.note)):""),"</li>");
                              }
                              html.push("</ul>");
                            }else{
                              html.push("<i>No overlays intersect this parcel (excluding DNT groups).</i>");
                            }
                          html.push("</div>",
                        "</div>",
                        "<div><h2 class='section-title'>Map</h2><img class='map' src='",baseShot.dataUrl,"' alt='Map'></div>",
                      "</div>",
                      "<div class='rpt-footer'>Generated by CornerstonePlus. Confirm against the current planning scheme and authoritative datasets before relying on this report.</div>",
                    "</div>");
        html.push("</div>");

        for(const s of shots){
          html.push("<div class='card' id='",s.id,"'>",
            "<div class='overlay-header'>",
              "<h2 class='section-title' style='margin:0'>",esc(s.title),"</h2>",
              "<div class='overlay-actions'>",
                "<a class='backbtn' href='#summary'>Back to Summary</a>",
              "</div>",
            "</div>",
            "<div class='map-legend'>",
              "<div><img class='map' src='",s.dataUrl,"' alt='",esc(s.title),"'></div>",
              "<div class='leg'>", (s.note ? "<div class='note'>"+esc(s.note)+"</div>" : ""), (s.legendHTML || ""), "</div>",
            "</div>",
          "</div>");
        }

        
html.push("<div class='card rpt-footer'><img src='",logoSrc,"' alt='Logo' style='width:18px;height:18px;vertical-align:-3px;border-radius:3px;border:1px solid #ddd;background:#fff;margin-right:6px'/> Moreton Bay Regional Council - CornerstonePlus. Indicative only.</div>");
html.push("</body>");

        const htmlOut = html.join("");
        return {html: htmlOut, title: reportFileTitle};
      }catch(e){ console.error(e); alert("Could not create report."); }
      finally{ showLoading(false); }
    }

    (function wireReportActions(){
      const openBtn=$("openReportBtn");
      if(openBtn){
        openBtn.addEventListener("click", ()=>{
          if(!isAccessActive()){
            setGateMessage("Session expired", "Your access window has ended. Please purchase again to open a report.");
            setGateVisible(true);
            setTimerVisible(false);
            return;
          }
          if(!lastReportHTML){ alert("Report not ready yet."); return; }
          const w=window.open("about:blank","_blank");
          if(!w){ alert("Please allow pop-ups to view the report."); return; }
          w.document.open();
          w.document.write(lastReportHTML);
          w.document.close();
          try{ w.document.title = lastReportTitle; }catch{}
          document.getElementById("rptOverlay").style.display="none";
          finalizeTokenAndLock();
        });
      }
    })();

    /* ---------------- Tabs & Home ---------------- */
    ;[["summary"],["setbacks"],["proposal"],["yield"]].forEach(([name])=>{
      const t=$("tab-"+name), p=$("panel-"+name);
      if(!t||!p) return;
      t.addEventListener("click",()=>{
        document.querySelectorAll(".tab").forEach(el=> el.setAttribute("aria-selected","false"));
        document.querySelectorAll(".panel").forEach(el=> el.classList.remove("active"));
        t.setAttribute("aria-selected","true"); p.classList.add("active");
      });
    });
    $("btnHome").addEventListener("click",()=>{
      fetch("Index.html",{method:"HEAD"}).then(()=>{ window.location.href="Index.html"; })
        .catch(()=>{
          if (history.length > 1) {
            history.back();
          } else {
            window.location.href = "./";
          }
        });
    });

    /* ---------------- POD Upload ---------------- */
    (function initPodUpload(){
      const form = $("podForm");
      const input = $("podFile");
      const statusEl = $("podStatus");
      const list = $("podResultList");
      const wrap = $("podResultWrap");
      const submitBtn = $("podSubmitBtn");
      const aligner = $("podAligner");
      const canvas = $("podCanvas");
      const alignStatus = $("podAlignStatus");
      const startAlignBtn = $("podStartAlignBtn");
      const clearAlignBtn = $("podClearAlignBtn");
      const pageSelect = $("podPageSelect");
      const pageInfo = $("podPageInfo");
      const btnRotL = $("podRotateLeft");
      const btnRotR = $("podRotateRight");
      const btnScaleDown = $("podScaleDown");
      const btnScaleUp = $("podScaleUp");
      const btnRefit = $("podRefitBtn");
      const btnFitParcel = $("fitParcelBtn");
      const traceStartBtn = $("traceStartBtn");
      const traceFinishBtn = $("traceFinishBtn");
      const traceUndoBtn = $("traceUndoBtn");
      const traceClearBtn = $("traceClearBtn");
      const traceStatus = $("traceStatus");
      if(!form || !input || !statusEl) return;

      const setStatus = (msg, isError=false)=>{
        statusEl.textContent = msg;
        statusEl.classList.toggle("error", !!isError);
      };
      const setAlignStatus = (msg)=>{ if(alignStatus) alignStatus.textContent = msg; };
      let podOverlayLayer=null;
      const podMarkerLayer=new GraphicsLayer({id:"podAlignMarkers", listMode:"hide"}); webmap.add(podMarkerLayer);
      const podFrameLayer=new GraphicsLayer({id:"podOverlayFrame", listMode:"hide"}); webmap.add(podFrameLayer);
      const podTraceLayer=new GraphicsLayer({id:"podTraceLayer", title:"POD Trace", listMode:"show"}); webmap.add(podTraceLayer);
      const podAlignState={
        imgData:null,
        imgWidth:0,
        imgHeight:0,
        pdf:null,
        pdfPage:1,
        imgPoints:[],
        mapPoints:[],
        mapHandle:null
      };
      const overlayState={
        center:null,
        baseW:0,
        baseH:0,
        rotDeg:0,
        scale:1,
        href:null,
        spatialReference:null,
        corners:null
      };

      const orderPoints=(arr)=>{
        if(!arr || arr.length<3) return arr||[];
        const pts=[...arr];
        const cx=pts.reduce((s,p)=>s+p.x,0)/pts.length;
        const cy=pts.reduce((s,p)=>s+p.y,0)/pts.length;
        pts.sort((a,b)=>Math.atan2(a.y-cy,a.x-cx)-Math.atan2(b.y-cy,b.x-cx));
        // rotate so first point is closest to top-left (smallest x+y)
        let startIdx=0, best=Infinity;
        pts.forEach((p,i)=>{
          const score=p.x+p.y;
          if(score<best){ best=score; startIdx=i; }
        });
        const ordered=[];
        for(let i=0;i<pts.length;i++){
          ordered.push(pts[(startIdx+i)%pts.length]);
        }
        // ensure we always return 4 points (truncate if needed)
        return ordered.slice(0,4);
      };
      const addMapMarker=(pt,idx)=>{
        try{
          podMarkerLayer.add(new Graphic({
            geometry: pt,
            symbol:{
              type:"simple-marker",
              style:"cross",
              color:[192,59,65,1],
              size:16,
              outline:{color:"#fff", width:1.5}
            },
            popupTemplate:null
          }));
        }catch{}
      };
      const resetAlign=()=>{
        podAlignState.imgPoints=[];
        podAlignState.mapPoints=[];
        if(podAlignState.mapHandle){
          podAlignState.mapHandle.remove();
          podAlignState.mapHandle=null;
        }
        try{ view.container.style.cursor="default"; }catch{}
        try{ podMarkerLayer.removeAll(); }catch{}
        overlayState.center=null;
        overlayState.href=null;
        overlayState.baseW=0;
        overlayState.baseH=0;
        overlayState.rotDeg=0;
        overlayState.scale=1;
        overlayState.corners=null;
        drawPodPreview();
        setAlignStatus("Pick 2 points on the POD, then 2 on the map.");
      };
      const clearOverlay=()=>{
        if(podOverlayLayer){
          try{ podOverlayLayer.source=[]; }catch{}
        }
        try{ podFrameLayer.removeAll(); }catch{}
        resetAlign();
      };
      const ensureOverlayLayer=()=>{
        if(!podOverlayLayer){
          podOverlayLayer = new MediaLayer({id:"podOverlayLayer", title:"POD Overlay", opacity:0.85, source:[], listMode:"show", visible:true});
          webmap.add(podOverlayLayer);
        }
        try{ podOverlayLayer.visible = true; }catch{}
        try{
          if(webmap.layers && typeof webmap.reorder==="function"){
            webmap.reorder(podOverlayLayer, webmap.layers.length-1); // push to top
          }
        }catch{}
        return podOverlayLayer;
      };
      const drawOverlayFromState=()=>{
        if(!overlayState.href || (!overlayState.corners && !overlayState.center)) return;
        let corners;
        if(overlayState.corners){
          corners = overlayState.corners;
        }else{
          const halfW = (overlayState.baseW * overlayState.scale) / 2;
          const halfH = (overlayState.baseH * overlayState.scale) / 2;
          const rad = overlayState.rotDeg * Math.PI/180;
          const cos = Math.cos(rad), sin = Math.sin(rad);
          const cornersLocal = [
            {x:-halfW,y:-halfH}, // top-left
            {x: halfW,y:-halfH}, // top-right
            {x: halfW,y: halfH}, // bottom-right
            {x:-halfW,y: halfH}  // bottom-left
          ];
          corners = cornersLocal.map(p=>({
            x: overlayState.center.x + p.x*cos - p.y*sin,
            y: overlayState.center.y + p.x*sin + p.y*cos,
            spatialReference: overlayState.spatialReference
          }));
        }
        const ordered = orderPoints(corners);
        const layer=ensureOverlayLayer();
        try{
          layer.source=[new ImageElement({
            href: overlayState.href,
            opacity:0.8,
            georeference:{
              type:"corners",
              topLeft: ordered[0],
              topRight: ordered[1],
              bottomRight: ordered[2],
              bottomLeft: ordered[3]
            }
          })];
          podFrameLayer.removeAll();
          podFrameLayer.add(new Graphic({
            geometry:{type:"polygon", spatialReference: overlayState.spatialReference, rings:[
              [ordered[0].x, ordered[0].y],
              [ordered[1].x, ordered[1].y],
              [ordered[2].x, ordered[2].y],
              [ordered[3].x, ordered[3].y],
              [ordered[0].x, ordered[0].y]
            ]},
            symbol:{ type:"simple-fill", color:[0,0,0,0], outline:{color:[255,0,0,180], width:2} }
          }));
        }catch(e){
          console.warn("overlay render failed", e);
        }
      };
      const computeOverlayFromPoints=(podPts,mapPts)=>{
        if(podPts.length<2 || mapPts.length<2) return null;
        const podW=podAlignState.imgWidth, podH=podAlignState.imgHeight;
        if(!podW || !podH) return null;
        const centerImg={x:podW/2,y:podH/2};
        const cornersImg=[
          {x:0,y:0},
          {x:podW,y:0},
          {x:podW,y:podH},
          {x:0,y:podH}
        ];
        // 4-point: map both sets to ordered corners
        if(podPts.length>=4 && mapPts.length>=4){
        const pOrd = orderPoints(podPts).slice(0,4);
        const mOrd = orderPoints(mapPts).slice(0,4);
        const width=Math.hypot(pOrd[1].x-pOrd[0].x, pOrd[1].y-pOrd[0].y);
        const height=Math.hypot(pOrd[3].x-pOrd[0].x, pOrd[3].y-pOrd[0].y);
        const center={
          x:(mOrd.reduce((s,p)=>s+p.x,0))/4,
          y:(mOrd.reduce((s,p)=>s+p.y,0))/4,
          spatialReference:mOrd[0].spatialReference
        };
          return {
            center,
            baseW:width,
            baseH:height,
            rotDeg:0,
            corners:mOrd,
            spatialReference:mOrd[0].spatialReference
          };
        }
        const fit=(mA,mB)=>{
          const pA=podPts[0], pB=podPts[1];
          const vP={x:pB.x-pA.x,y:pB.y-pA.y};
          const vM={x:mB.x-mA.x,y:mB.y-mA.y};
          const lenP=Math.hypot(vP.x,vP.y);
          const lenM=Math.hypot(vM.x,vM.y);
          if(lenP===0 || lenM===0) return null;
          const scale=lenM/lenP;
          const rot=Math.atan2(vM.y,vM.x)-Math.atan2(vP.y,vP.x);
          const cos=Math.cos(rot), sin=Math.sin(rot);
          const rotScale=(p)=>({x:(p.x*cos-p.y*sin)*scale, y:(p.x*sin+p.y*cos)*scale});
          const t={
            x: mA.x - rotScale({x:pA.x-centerImg.x,y:pA.y-centerImg.y}).x,
            y: mA.y - rotScale({x:pA.x-centerImg.x,y:pA.y-centerImg.y}).y,
            spatialReference: mA.spatialReference
          };
          const transform=(pt)=>{
            const rel={x:pt.x-centerImg.x,y:pt.y-centerImg.y};
            const r=rotScale(rel);
            return {x:t.x+r.x,y:t.y+r.y, spatialReference:t.spatialReference};
          };
          const tpA=transform(pA), tpB=transform(pB);
          const err=Math.hypot(tpA.x-mA.x,tpA.y-mA.y)+Math.hypot(tpB.x-mB.x,tpB.y-mB.y);
          const corners=cornersImg.map(c=>transform(c));
          const center={
            x:(corners.reduce((s,p)=>s+p.x,0))/4,
            y:(corners.reduce((s,p)=>s+p.y,0))/4,
            spatialReference:t.spatialReference
          };
          const width=Math.hypot(corners[1].x-corners[0].x, corners[1].y-corners[0].y);
          const height=Math.hypot(corners[3].x-corners[0].x, corners[3].y-corners[0].y);
          const rotDeg=Math.atan2(corners[1].y-corners[0].y, corners[1].x-corners[0].x)*180/Math.PI;
          return {err, center, width, height, rotDeg, corners};
        };
        // try both map point orders to make user order irrelevant
        const fit1=fit(mapPts[0], mapPts[1]);
        const fit2=fit(mapPts[1], mapPts[0]);
        const best = (!fit2 || (fit1 && fit1.err<=fit2.err)) ? fit1 : fit2;
        if(!best) return null;
        return {
          center: best.center,
          baseW: best.width,
          baseH: best.height,
          rotDeg: best.rotDeg,
          corners: orderPoints(best.corners),
          spatialReference: best.center.spatialReference
        };
      };
      const drawPodPreview=()=>{
        if(!canvas || !podAlignState.imgData) return;
        const ctx = canvas.getContext("2d");
        const img = new Image();
        img.onload=()=>{
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.clearRect(0,0,canvas.width,canvas.height);
          ctx.drawImage(img,0,0);
          ctx.fillStyle="rgba(192,59,65,0.9)";
          ctx.strokeStyle="white";
          ctx.lineWidth=2;
          podAlignState.imgPoints.forEach((p,i)=>{
            ctx.beginPath();
            ctx.arc(p.x,p.y,6,0,Math.PI*2);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle="white";
            ctx.font="12px sans-serif";
            ctx.fillText(String(i+1), p.x+8, p.y+4);
            ctx.fillStyle="rgba(192,59,65,0.9)";
          });
        };
        img.src = podAlignState.imgData;
      };
      const renderPdfPage=async(pageNum=1)=>{
        if(!podAlignState.pdf || !canvas) return;
        try{
          const pdfPage = await podAlignState.pdf.getPage(pageNum);
          const viewport = pdfPage.getViewport({scale:2.5});
          const ctx = canvas.getContext("2d");
          canvas.width = viewport.width;
          canvas.height = viewport.height;
          ctx.fillStyle="#111";
          ctx.fillRect(0,0,canvas.width,canvas.height);
          await pdfPage.render({canvasContext:ctx, viewport}).promise;
          podAlignState.imgData = canvas.toDataURL("image/png");
          podAlignState.imgWidth = canvas.width;
          podAlignState.imgHeight = canvas.height;
          podAlignState.imgPoints=[];
          drawPodPreview();
          setAlignStatus("Click 2 points on the POD, then 2 points on the map.");
          if(pageInfo) pageInfo.textContent = `Rendering page ${pageNum} of ${podAlignState.pdf.numPages}`;
        }catch(e){
          console.warn("Render pdf page failed",e);
          setAlignStatus("Could not render this page.");
        }
      };
      const placeOverlay=()=>{
        if(podAlignState.imgPoints.length<2 || podAlignState.mapPoints.length<2){
          setAlignStatus("Need 2 POD points and 2 map points.");
          return;
        }
        const fit = computeOverlayFromPoints(podAlignState.imgPoints, podAlignState.mapPoints);
        if(!fit){
          setAlignStatus("Could not compute fit from points.");
          return;
        }
        overlayState.center = fit.center;
        overlayState.baseW = fit.baseW;
        overlayState.baseH = fit.baseH;
        overlayState.rotDeg = fit.rotDeg;
        overlayState.scale = 1;
        overlayState.href = podAlignState.imgData;
        overlayState.spatialReference = fit.spatialReference;
        overlayState.corners = fit.corners;
        drawOverlayFromState();
        setAlignStatus(`Overlay placed. rot ${overlayState.rotDeg.toFixed(1)}°, scale ${(overlayState.scale*100).toFixed(1)}%. Use Clear to reset or nudge to fine tune.`);
        try{ view.goTo(fit.center,{animate:false}); }catch{}
      };
      if(canvas){
        canvas.addEventListener("click",evt=>{
          if(!podAlignState.imgData) return;
          const rect=canvas.getBoundingClientRect();
          const x=(evt.clientX-rect.left)*(canvas.width/rect.width);
          const y=(evt.clientY-rect.top)*(canvas.height/rect.height);
          if(podAlignState.imgPoints.length>=4) podAlignState.imgPoints=[];
          podAlignState.imgPoints.push({x,y});
          drawPodPreview();
          const need = podAlignState.imgPoints.length>=4 ? 4 : 2;
          setAlignStatus(`POD points: ${podAlignState.imgPoints.length}/${need}. ${podAlignState.imgPoints.length<need?"Click another point on the POD.":"Now click matching points on the map (press Pick points)."} `);
        });
      }
      startAlignBtn?.addEventListener("click",()=>{
        if(!podAlignState.imgData){
          setAlignStatus("Upload a POD first.");
          return;
        }
        if(podAlignState.imgPoints.length<2){
          setAlignStatus("Pick at least 2 points on the POD preview first (4 for best fit).");
          return;
        }
        podAlignState.mapPoints=[];
        if(podAlignState.mapHandle){
          podAlignState.mapHandle.remove();
          podAlignState.mapHandle=null;
        }
        ensureOverlayLayer();
        try{ podMarkerLayer.removeAll(); }catch{}
        try{ podFrameLayer.removeAll(); }catch{}
        view.container.style.cursor="crosshair";
        const need = podAlignState.imgPoints.length>=4 ? 4 : 2;
        setAlignStatus(`Click ${need} matching point(s) on the map (zoom in for accuracy).`);
        podAlignState.mapHandle = view.on("click",evt=>{
          const pt = view.toMap(evt);
          if(!pt){
            setAlignStatus("Click inside the map area.");
            return;
          }
          podAlignState.mapPoints.push(pt);
          addMapMarker(pt, podAlignState.mapPoints.length);
          const needNow = podAlignState.imgPoints.length>=4 ? 4 : 2;
          setAlignStatus(`Map points: ${podAlignState.mapPoints.length}/${needNow}`);
          if(podAlignState.mapPoints.length>=needNow){
            podAlignState.mapHandle.remove();
            podAlignState.mapHandle=null;
            view.container.style.cursor="default";
            placeOverlay();
          }
        });
      });
      const adjustOverlay=(deltaRot, deltaScale)=>{
        if(!overlayState.center) return;
        if(typeof deltaRot==="number") overlayState.rotDeg += deltaRot;
        if(typeof deltaScale==="number") overlayState.scale = Math.max(0.1, overlayState.scale * deltaScale);
        // when nudging, recompute corners from center/rot/scale to keep transforms aligned
        overlayState.corners=null;
        drawOverlayFromState();
        setAlignStatus(`Overlay rot ${overlayState.rotDeg.toFixed(1)}°, scale ${(overlayState.scale*100).toFixed(1)}%.`);
      };
      btnRotL?.addEventListener("click",()=>adjustOverlay(-2, null));
      btnRotR?.addEventListener("click",()=>adjustOverlay(2, null));
      btnScaleDown?.addEventListener("click",()=>adjustOverlay(null, 0.95));
      btnScaleUp?.addEventListener("click",()=>adjustOverlay(null, 1.05));
      btnRefit?.addEventListener("click",()=>{
        if(podAlignState.imgPoints.length>=2 && podAlignState.mapPoints.length>=2){
          placeOverlay();
        }else{
          setAlignStatus("Pick 2 POD points and 2 map points, then Refit.");
        }
      });
      btnFitParcel?.addEventListener("click",()=>{
        const feat = lastParcelInfo?.feature;
        if(!feat || !feat.geometry){
          setAlignStatus("Select a parcel first, then Fit to parcel.");
          return;
        }
        const geom = feat.geometry.extent ? feat.geometry : geometryEngine.convexHull(feat.geometry);
        const ext = geom.extent || geometryEngine.extent(geom);
        if(!ext){
          setAlignStatus("Could not read parcel extent.");
          return;
        }
        const corners=[
          {x:ext.xmin,y:ext.ymax,spatialReference:geom.spatialReference},
          {x:ext.xmax,y:ext.ymax,spatialReference:geom.spatialReference},
          {x:ext.xmax,y:ext.ymin,spatialReference:geom.spatialReference},
          {x:ext.xmin,y:ext.ymin,spatialReference:geom.spatialReference}
        ];
        overlayState.center = {x:(ext.xmin+ext.xmax)/2, y:(ext.ymin+ext.ymax)/2, spatialReference:geom.spatialReference};
        overlayState.baseW = ext.width;
        overlayState.baseH = ext.height;
        overlayState.rotDeg = 0;
        overlayState.scale = 1;
        overlayState.href = podAlignState.imgData;
        overlayState.spatialReference = geom.spatialReference;
        overlayState.corners = orderPoints(corners);
        drawOverlayFromState();
        setAlignStatus("Overlay fitted to parcel extent. Use nudge/trace to refine.");
        try{ view.goTo(ext,{animate:false}); }catch{}
      });

      const drawTracePreview=()=>{
        try{ if(traceState.preview) podTraceLayer.remove(traceState.preview); }catch{}
        if(traceState.points.length<2) return;
        const geom = traceState.points.length>=3
          ? {type:"polygon", spatialReference:view.spatialReference, rings:[traceState.points.map(p=>[p.x,p.y]).concat([[traceState.points[0].x, traceState.points[0].y]])]}
          : {type:"polyline", spatialReference:view.spatialReference, paths:[traceState.points.map(p=>[p.x,p.y])]};
        const sym = geom.type==="polygon"
          ? {type:"simple-fill", color:[255,0,0,40], outline:{color:[255,0,0,200], width:2}}
          : {type:"simple-line", color:[255,0,0,200], width:2};
        traceState.preview = new Graphic({geometry:geom, symbol:sym});
        podTraceLayer.add(traceState.preview);
      };
      const stopTrace=()=>{
        if(traceState.handle){ traceState.handle.remove(); traceState.handle=null; }
        traceState.active=false;
        view.container.style.cursor="default";
      };
      const setTraceMsg=msg=>{ if(traceStatus) traceStatus.textContent=msg; };

      traceStartBtn?.addEventListener("click",()=>{
        stopTrace();
        traceState.points=[];
        drawTracePreview();
        traceState.active=true;
        view.container.style.cursor="crosshair";
        setTraceMsg("Tracing: click to add vertices, Finish to close.");
        traceState.handle = view.on("immediate-click",evt=>{
          const pt = view.toMap(evt);
          if(!pt) return;
          const pObj={x:pt.x,y:pt.y,spatialReference:pt.spatialReference};
          traceState.points.push(pObj);
          addTraceMarker(pt);
          drawTracePreview();
          setTraceMsg(`Tracing: ${traceState.points.length} point(s). Finish to close.`);
        });
      });
      traceFinishBtn?.addEventListener("click",()=>{
        if(!traceState.active || traceState.points.length<3){
          setTraceMsg("Need at least 3 points to finish.");
          return;
        }
        stopTrace();
        drawTracePreview();
        setTraceMsg("Trace saved. Start to digitize another.");
      });
      traceUndoBtn?.addEventListener("click",()=>{
        if(!traceState.points.length) return;
        traceState.points.pop();
        try{ podMarkerLayer.removeAll(); traceState.points.forEach(p=>addTraceMarker(p)); }catch{}
        drawTracePreview();
        setTraceMsg(`Tracing: ${traceState.points.length} point(s).`);
      });
      traceClearBtn?.addEventListener("click",()=>{
        stopTrace();
        traceState.points=[];
        try{ podTraceLayer.removeAll(); }catch{}
        try{ podMarkerLayer.removeAll(); }catch{}
        setTraceMsg("Trace cleared.");
      });
      pageSelect?.addEventListener("change",async()=>{
        const pageNum = Number(pageSelect.value);
        if(Number.isFinite(pageNum) && pageNum>=1 && podAlignState.pdf){
          await renderPdfPage(pageNum);
        }
      });
      clearAlignBtn?.addEventListener("click",()=>{
        clearOverlay();
        setAlignStatus("Overlay cleared.");
      });

      const setBusy = busy=>{
        if(submitBtn){
          submitBtn.disabled = busy;
          submitBtn.textContent = busy ? "Uploading..." : "Upload & Import";
        }
        if(input){
          input.disabled = busy;
        }
      };
      const renderResults = (items=[])=>{
        if(!wrap || !list) return;
        if(!items.length){
          wrap.hidden = true;
          list.innerHTML = "";
          return;
        }
        wrap.hidden = false;
        list.innerHTML = items.map(sub=>{
          const lotRaw = sub.lot || "";
          const planRaw = sub.plan || "";
          const lot = htmlEsc(lotRaw || "?");
          const plan = htmlEsc(planRaw || "Unknown plan");
          const area = sub.areaSqm ? `${sub.areaSqm.toLocaleString()} sqm` : "Area N/A";
          const btn = (sub.lot && sub.plan)
            ? `<button class="pod-zoom-btn" data-lot="${attrEsc(lotRaw)}" data-plan="${attrEsc(planRaw)}">Use</button>`
            : "";
          return `<li><div class="pod-result-row">${btn}<div>Lot ${lot} on ${plan} (${area})</div></div></li>`;
        }).join("");
      };
      list?.addEventListener("click", async evt=>{
        const btn = evt.target.closest(".pod-zoom-btn");
        if(!btn) return;
        evt.preventDefault();
        let {lot, plan} = btn.dataset;
        if(!lot || !plan){
          const txt = (btn.closest(".pod-result-row")?.innerText || "").trim();
          const m = txt.match(/Lot\s+(\S+)\s+on\s+(\S+)/i);
          if(m){ lot = m[1]; plan = m[2]; }
        }
        if(!lot || !plan){
          setStatus("Missing lot/plan on selection.", true);
          return;
        }
        setBusy(true);
        setStatus(`Zooming to Lot ${lot} on ${plan}...`);
        const ok = await focusOnLotPlan(lot, plan);
        setBusy(false);
        setStatus(ok ? `Focused on Lot ${lot} on ${plan}.` : `Could not locate Lot ${lot} on ${plan} in the available parcel datasets.`, !ok);
      });

      input.addEventListener("change",()=>{
        const file = input.files && input.files[0];
        const nameEl = $("podFileName");
        if(file){
          if(nameEl) nameEl.textContent = file.name;
          setStatus(`Ready to import ${file.name}`);
        }else{
          if(nameEl) nameEl.textContent = "No file chosen";
          setStatus("Select a POD PDF to begin.");
          renderResults([]);
          if(aligner) aligner.hidden = true;
        }
      });

      form.addEventListener("submit", async evt=>{
        evt.preventDefault();
        if(!input.files || !input.files.length){
          setStatus("Choose a POD PDF first.", true);
          return;
        }
        const file = input.files[0];

        setBusy(true);
        setStatus("Parsing PDF locally...");
        renderResults([]);
        if(aligner) aligner.hidden = true;

        try{
          const text = await extractPdfText(file);
          if(!text || !text.trim()){
            throw new Error("PDF did not contain readable text.");
          }
          const subdivisions = parseSubdivisionsFromText(text);
          renderResults(subdivisions);
          // Render first page preview for overlaying
          if(window.pdfjsLib && canvas && aligner){
            try{
          const buffer = await file.arrayBuffer();
          const pdf = await window.pdfjsLib.getDocument({data:buffer}).promise;
          podAlignState.pdf = pdf;
          podAlignState.pdfPage = 1;
          if(pageSelect){
            pageSelect.innerHTML = "";
            for(let i=1;i<=pdf.numPages;i++){
              const opt=document.createElement("option");
              opt.value=String(i); opt.textContent=String(i);
              if(i===1) opt.selected=true;
              pageSelect.appendChild(opt);
            }
          }
          podAlignState.imgPoints=[];
          podAlignState.mapPoints=[];
          aligner.hidden = false;
          await renderPdfPage(1);
        }catch(e){
          console.warn("POD preview render failed", e);
          setAlignStatus("Could not render POD preview.");
        }
      }

          const count = subdivisions.length;
          let msg = count ? `Parsed ${count} subdivision${count===1? "":"s"} locally.` : "No subdivisions detected.";
          let statusError = false;
          const focusTarget = subdivisions.find(sub=>sub.lot && sub.plan);
          if(count === 1 && focusTarget){
            const zoomed = await focusOnLotPlan(focusTarget.lot, focusTarget.plan);
            if(zoomed){
              msg += ` Zoomed to Lot ${focusTarget.lot} on ${focusTarget.plan}.`;
            }else{
              msg += ` Could not locate Lot ${focusTarget.lot} on ${focusTarget.plan} in the available parcel datasets.`;
              statusError = true;
            }
          }else if(count > 1){
            msg += " Choose a lot below to zoom.";
          }
          msg += " Upload to ArcGIS coming soon.";
          setStatus(msg, statusError);
        }catch(err){
          console.error(err);
          setStatus(err.message || "Local parsing failed", true);
        }finally{
          setBusy(false);
        }
      });

      const dropZone = $("podDropZone");
      const setFile = file=>{
        if(!file) return;
        const dt = new DataTransfer();
        dt.items.add(file);
        input.files = dt.files;
        const nameEl = $("podFileName");
        if(nameEl) nameEl.textContent = file.name;
        setStatus(`Ready to import ${file.name}`);
      };
      const prevent = e=>{ e.preventDefault(); e.stopPropagation(); };
      ["dragenter","dragover","dragleave","drop"].forEach(ev=>{
        dropZone?.addEventListener(ev, prevent);
      });
      dropZone?.addEventListener("dragenter", ()=> dropZone.classList.add("dragover"));
      dropZone?.addEventListener("dragleave", ()=> dropZone.classList.remove("dragover"));
      dropZone?.addEventListener("dragend", ()=> dropZone.classList.remove("dragover"));
      dropZone?.addEventListener("drop", ev=>{
        dropZone.classList.remove("dragover");
        const file = ev.dataTransfer?.files?.[0];
        if(file && file.type==="application/pdf"){
          setFile(file);
        }else{
          setStatus("Drop a PDF file.", true);
        }
      });
    })();

    /* ============================================================
       === Lot/Plan Search source (QLD) ============================
       ============================================================ */

    function normalizePlanText(p){ return String(p||"").toUpperCase().replace(/\s+/g,""); }
    function parseLotPlan(text){
      if(!text) return null;
      let s=String(text).toUpperCase();
      s=s.replace(/[,]+/g," ").replace(/\bon\b/ig," ").replace(/\blot\b/ig," ").replace(/\s+/g," ").trim();
      let m = s.match(/^\s*(\d+)\s*\/\s*([A-Z]{1,4}\s*\d{1,8})\s*$/);
      if(m) return {lot:m[1], plan:normalizePlanText(m[2])};
      m = s.match(/^\s*(\d+)\s+([A-Z]{1,4}\s*\d{1,8})\s*$/);
      if(m) return {lot:m[1], plan:normalizePlanText(m[2])};
      m = s.match(/^\s*([A-Z]{1,4}\s*\d{1,8})\s+(\d+)\s*$/);
      if(m) return {lot:m[2], plan:normalizePlanText(m[1])};
      return null;
    }

    let _parcelLayerCache=null;
    async function getParcelLayers(){
      if(_parcelLayerCache) return _parcelLayerCache;
      const candidates=flattenFeatureNodes();
      const polys=[];
      for(const n of candidates){
        try{
          await n.load();
          if(n.geometryType==="polygon" && (looksLikeParcelLayer(n) || hasParcelFields(n))){
            polys.push(n);
          }
        }catch{}
      }
      _parcelLayerCache=polys;
      return polys;
    }

    function escSQL(s){ return String(s).replace(/'/g,"''"); }
    function isIntegerField(f){ const t=String(f.type||"").toLowerCase(); return t.indexOf("integer")!==-1; }
    function isTextField(f){ const t=String(f.type||"").toLowerCase(); return t.indexOf("string")!==-1; }

    function buildFallbackLotPlanWhere(lot, plan){
      if(!lot || !plan) return null;
      const lotU = escSQL(String(lot).toUpperCase());
      const planU = escSQL(plan.toUpperCase());
      const planCompact = escSQL(plan.toUpperCase().replace(/[^A-Z0-9]/g,""));
      const lotPlanFull = escSQL((String(lot)+"/"+plan).toUpperCase());
      const lotPlanCompact = escSQL((String(lot)+plan).toUpperCase().replace(/[^A-Z0-9]/g,""));
      return [
        "(",
        `  UPPER(lot)='${lotU}'`,
        `  OR UPPER(lotplan) LIKE '%${lotPlanFull}%'`,
        `  OR REPLACE(REPLACE(REPLACE(UPPER(lotplan),' ',''),'-',''),'/','') LIKE '%${lotPlanCompact}%'`,
        ") AND (",
        `  UPPER(plan) LIKE '%${planU}%'`,
        `  OR REPLACE(REPLACE(REPLACE(UPPER(plan),' ',''),'-',''),'/','') LIKE '%${planCompact}%'`,
        `  OR REPLACE(REPLACE(REPLACE(UPPER(lotplan),' ',''),'-',''),'/','') LIKE '%${lotPlanCompact}%'`,
        ")"
      ].join("\n");
    }

    async function queryLotPlanFallback(lot, plan){
      if(!LOTPLAN_FALLBACK_URLS.length) return [];
      const results=[];
      const compact = `${lot}${plan}`.toUpperCase().replace(/[^A-Z0-9]/g,"");
      const planU = String(plan||"").toUpperCase();
      const lotU = String(lot||"").toUpperCase();
      for(const url of LOTPLAN_FALLBACK_URLS){
        const isLotplanOnly = /LandParcelPropertyFramework/gi.test(url);
        const where = isLotplanOnly
          ? `UPPER(lotplan)='${compact}'`
          : (buildFallbackLotPlanWhere(lot, plan) || `UPPER(lotplan)='${compact}'`);
        try{
          const params = new URLSearchParams({
            f:"json",
            where,
            outFields:"*",
            returnGeometry:"true",
            outSR:String(view?.spatialReference?.wkid||3857),
            maxRecordCountFactor:"5"
          });
          const res = await fetch(`${url}/query`,{
            method:"POST",
            headers:{"Content-Type":"application/x-www-form-urlencoded"},
            body:params
          });
          if(!res.ok) throw new Error("Fallback lot plan query failed: "+res.status);
          const json = await res.json();
          (json.features||[]).forEach(f=>{
            const g = Graphic.fromJSON ? Graphic.fromJSON(f) : new Graphic({geometry:f.geometry,attributes:f.attributes});
            if(!g.geometry && f.geometry) g.geometry = f.geometry;
            if(g.geometry && !g.geometry.spatialReference){
              g.geometry.spatialReference = view?.spatialReference || { wkid: 102100 };
            }
            results.push({layer:{title:"Lot/Plan (Fallback)"}, feature:g});
          });
          if(results.length) break;
        }catch(e){
          console.warn("Lot/Plan fallback error:", e);
        }
      }
      // If strict queries failed, try a looser search on the main cadastre polygons
      if(!results.length){
        const cadUrl = LOTPLAN_FALLBACK_URLS.find(u=>/LandParcelPropertyFramework\/MapServer\/4/i.test(u));
        if(cadUrl){
          try{
            const whereLoose = [
              `UPPER(lotplan) LIKE '%${compact}%'`,
              `UPPER(lotplan) LIKE '%${planU}%'`,
              `UPPER(lotplan) LIKE '%${lotU}/${planU}%'`,
              `REPLACE(REPLACE(UPPER(lotplan), ' ', ''), '/', '') LIKE '%${compact}%'`
            ].join(" OR ");
            const params = new URLSearchParams({
              f:"json",
              where:whereLoose,
              outFields:"*",
              returnGeometry:"true",
              outSR:String(view?.spatialReference?.wkid||3857),
              maxRecordCountFactor:"5"
            });
            const res = await fetch(`${cadUrl}/query`,{
              method:"POST",
              headers:{"Content-Type":"application/x-www-form-urlencoded"},
              body:params
            });
            if(res.ok){
              const json = await res.json();
              (json.features||[]).forEach(f=>{
                const g = Graphic.fromJSON ? Graphic.fromJSON(f) : new Graphic({geometry:f.geometry,attributes:f.attributes});
                if(!g.geometry && f.geometry) g.geometry = f.geometry;
                if(g.geometry && !g.geometry.spatialReference){
                  g.geometry.spatialReference = view?.spatialReference || { wkid: 102100 };
                }
                results.push({layer:{title:"Lot/Plan (Fallback loose)"}, feature:g});
              });
            }
          }catch(e){
            console.warn("Lot/Plan loose fallback error:", e);
          }
        }
      }
      return results;
    }

    function buildLotPlanWhere(layer, lot, plan){
      const flds = Array.isArray(layer.fields)?layer.fields:[];
      const lotFields = flds.filter(f=>{
        const nm = (f.name||"").toUpperCase();
        if(/LOT_AREA/.test(nm)) return false;
        return /\b(LOT|LOTNO|LOT_NO|LOTNUMBER|LOT_NUM|LOTNUM)\b/.test(nm) || /^LOT$/.test(nm);
      });
      const planFields = flds.filter(f=>{
        const nm = (f.name||"").toUpperCase();
        return /\b(PLAN|PLAN_NO|PLANNO|LOT_PLAN|LOTPLAN|LOT_PLAN_TXT|LOTPLAN_TXT)\b/.test(nm);
      });

      const lotClauses=[];
      const lotNum = Number(lot);
      for(const f of lotFields){
        if(isIntegerField(f) && !Number.isNaN(lotNum)){
          lotClauses.push(`${f.name}=${lotNum}`);
        }else if(isTextField(f)){
          lotClauses.push(`UPPER(${f.name}) LIKE '%${escSQL(String(lot).toUpperCase())}%'`);
        }
      }

      const planClauses=[];
      const planU = escSQL(plan.toUpperCase());
      const planCompact = escSQL(plan.toUpperCase().replace(/[^A-Z0-9]/g,""));
      const lotPlanFull = escSQL((String(lot)+"/"+plan).toUpperCase());
      const lotPlanCompact = escSQL((String(lot)+plan).toUpperCase().replace(/[^A-Z0-9]/g,""));
      for(const f of planFields){
        if(isTextField(f)){
          const fieldExpr = `UPPER(${f.name})`;
          const scrubExpr = `REPLACE(REPLACE(REPLACE(${fieldExpr},' ',''),'-',''),'/','')`;
          planClauses.push(`${fieldExpr} LIKE '%${planU}%'`);
          planClauses.push(`${scrubExpr} LIKE '%${planCompact}%'`);
          if(/LOT[_ ]?PLAN|LOTPLAN|LOT_PLAN/i.test(f.name)){
            planClauses.push(`${fieldExpr} LIKE '%${lotPlanFull}%'`);
            planClauses.push(`${scrubExpr} LIKE '%${lotPlanCompact}%'`);
          }
        }
      }

      const parts=[];
      if(lotClauses.length) parts.push("("+lotClauses.join(" OR ")+")");
      if(planClauses.length) parts.push("("+planClauses.join(" OR ")+")");
      if(!parts.length) return null;
      return parts.join(" AND ");
    }

    async function queryLotPlanAcrossLayers(lot, plan){
      const layers = await getParcelLayers();
      const out=[];
      for(const L of layers){
        try{
          const where = buildLotPlanWhere(L, lot, plan);
          if(!where) continue;
          const q = await L.queryFeatures({
            where,
            outFields:["*"],
            returnGeometry:true,
            maxRecordCountFactor:5
          });
          for(const f of (q.features||[])){
            out.push({layer:L, feature:f});
          }
        }catch(e){ /* ignore per-layer errors */ }
      }
      if(!out.length){
        const fallback = await queryLotPlanFallback(lot, plan);
        if(fallback?.length) out.push(...fallback);
      }
      return out;
    }

    async function focusOnLotPlan(lot, plan){
      if(!lot || !plan) return false;
      try{
        await view.when();
        showLoading(true);
        const lotTrim = String(lot).trim();
        const planTrim = String(plan).trim();
        console.log("[LotPlan] searching", lotTrim, planTrim);

        const pickBest = hits=>{
          if(!hits || !hits.length) return null;
          const exact = hits.find(r=>isExactLotPlan(r.feature, lotTrim, planTrim));
          if(exact) return exact;
          let best=null,bestScore=0;
          for(const r of hits){
            const s=scoreLotPlan(r.feature, lotTrim, planTrim);
            if(s>bestScore){ best=r; bestScore=s; }
          }
          if(bestScore>0 && best) return best;
          const planOnly = hits.find(r=>matchesPlanOnly(r.feature, planTrim));
          return planOnly || null;
        };

        // Try fallback first (statewide cadastre)
        const fb = await queryLotPlanFallback(lotTrim, planTrim);
        const fbBest = pickBest(fb);
        if(fbBest){
          await focusOnParcelFeature(fbBest.feature,{shouldZoom:true});
          return true;
        }

        const layerHits = await queryLotPlanAcrossLayers(lotTrim, planTrim);
        if(layerHits && layerHits.length){
          const bestLayer = pickBest(layerHits);
          if(bestLayer){
            await focusOnParcelFeature(bestLayer.feature,{shouldZoom:true});
            return true;
          }
        }

        console.warn("[LotPlan] no matching hits for", lotTrim, planTrim);
        return false;
      }catch(err){
        console.warn("focusOnLotPlan error:", err);
        return false;
      }finally{
        showLoading(false);
      }
    }

    const lotPlanSource = {
      name: "Lot/Plan (QLD)",
      placeholder: "12/SP12345 or 'Lot 12 on SP12345'",
      getSuggestions: async (params)=>{
        const p = parseLotPlan(params.text);
        if(!p) return [];
        return [{ key: p.lot+"/"+p.plan, text: "Lot "+p.lot+" on "+p.plan, sourceIndex: 0 }];
      },
      getResults: async (params)=>{
        let txt = params.text || "";
        if(params.suggestResult && params.suggestResult.key) txt = params.suggestResult.key;
        const p = parseLotPlan(txt);
        if(!p) return [];
        const matches = await queryLotPlanAcrossLayers(p.lot, p.plan);
        return matches.map((m)=>({
          name: "Lot "+p.lot+" on "+p.plan+" — "+(m.layer.title||"Parcels"),
          feature: m.feature,
          extent: m.feature?.geometry?.extent
        }));
      },
      zoomScale: 1000
    };

    search.sources.add(lotPlanSource);

    search.on("select-result", async (e)=>{
      try{
        const feat = e.result && e.result.feature;
        if(feat && feat.geometry){
          await focusOnParcelFeature(feat,{shouldZoom:true});
        }
      }catch(err){ console.warn("select-result handler:", err); }
    });

  </script>


</body>
</html>
